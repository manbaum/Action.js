// Generated by CoffeeScript 1.9.3
(function() {
  var Action, ignore, mkFreeze;

  ignore = function() {};

  Action = (function() {
    function Action(action1) {
      this.action = action1;
    }

    Action.prototype._go = function(cb) {
      return this.action(cb);
    };

    Action.prototype.next = function(cb) {
      var self;
      self = this;
      return new Action(function(_cb) {
        return self.action(function(data) {
          var _data;
          if (data instanceof Error) {
            return _cb(data);
          } else {
            _data = cb(data);
            if (_data instanceof Action) {
              return _data._go(_cb);
            } else {
              return _cb(_data);
            }
          }
        });
      });
    };

    Action.prototype.guard = function(cb) {
      var self;
      self = this;
      return new Action(function(_cb) {
        return self.action(function(data) {
          var _data;
          if (data instanceof Error) {
            _data = cb(data);
            if (_data instanceof Action) {
              return _data._go(_cb);
            } else {
              return _cb(_data);
            }
          } else {
            return _cb(data);
          }
        });
      });
    };

    Action.prototype.go = function(cb) {
      return this.action(function(data) {
        if (data instanceof Error) {
          throw data;
        } else if (cb != null) {
          return cb(data);
        }
      });
    };

    return Action;

  })();

  Action.wrap = function(data) {
    return new Action(function(cb) {
      return cb(data);
    });
  };

  mkFreeze = function(throwError) {
    return function(action) {
      var callbacks, cb, data, pending;
      pending = true;
      data = void 0;
      callbacks = [];
      cb = function(_data) {
        var j, len, results1;
        if (pending) {
          data = _data;
          pending = false;
          results1 = [];
          for (j = 0, len = callbacks.length; j < len; j++) {
            cb = callbacks[j];
            results1.push(cb(_data));
          }
          return results1;
        }
      };
      if (throwError) {
        action.go(cb);
      } else {
        action._go(cb);
      }
      return new Action(function(cb) {
        if (pending) {
          return callbacks.push(cb);
        } else {
          return cb(data);
        }
      });
    };
  };

  Action.freeze = mkFreeze(true);

  Action._freeze = mkFreeze(false);

  Action.safe = function(err, fn) {
    return function(data) {
      var e;
      try {
        return fn(data);
      } catch (_error) {
        e = _error;
        return err;
      }
    };
  };

  Action.safeRaw = function(fn) {
    return function(data) {
      var e;
      try {
        return fn(data);
      } catch (_error) {
        e = _error;
        return e;
      }
    };
  };

  Action.sequence = function(monadicActions) {
    return function(init) {
      var a, j, len, monadicAction, ref;
      if (monadicActions.length > 0) {
        a = monadicActions[0](init);
        ref = monadicActions.slice(1);
        for (j = 0, len = ref.length; j < len; j++) {
          monadicAction = ref[j];
          a = a.next(monadicAction);
        }
        return a;
      } else {
        return Action.wrap(new Error('No monadic actions given'));
      }
    };
  };

  Action.any = function(actions) {
    return new Action(function(cb) {
      var action, j, len, results1;
      results1 = [];
      for (j = 0, len = actions.length; j < len; j++) {
        action = actions[j];
        results1.push(action._go(function(data) {
          cb(data);
          return cb = ignore;
        }));
      }
      return results1;
    });
  };

  Action.anySuccess = function(actions) {
    var countDown;
    countDown = actions.length;
    return new Action(function(cb) {
      var action, j, len, results1;
      results1 = [];
      for (j = 0, len = actions.length; j < len; j++) {
        action = actions[j];
        results1.push(action._go(function(data) {
          countDown--;
          if (!(data instanceof Error)) {
            cb(data);
            cb = ignore;
            return countDown = -1;
          } else if (countDown === 0) {
            return cb(new Error('All actions failed'));
          }
        }));
      }
      return results1;
    });
  };

  Action.replicate = function(times, a) {
    var res;
    res = [];
    while (times-- !== 0) {
      res.push(a);
    }
    return res;
  };

  Action.repeat = function(times, action) {
    var monadicA;
    monadicA = function() {
      return action;
    };
    return (Action.sequence(Action.replicate(times, monadicA)))();
  };

  Action.retry = function(times, action) {
    var a;
    a = action.guard(function(e) {
      if (times-- !== 0) {
        return a;
      } else {
        return new Error('Retry limit reached');
      }
    });
    return a;
  };

  Action.gapRetry = function(times, interval, action) {
    var a;
    a = action.guard(function(e) {
      return new Action(function(cb) {
        return setTimeout(cb, interval);
      }).next(function() {
        if (times-- !== 0) {
          return a;
        } else {
          return new Error('Retry limit reached');
        }
      });
    });
    return a;
  };

  Action.all = function(actions) {
    var countDown, results;
    results = [];
    countDown = actions.length;
    return new Action(function(cb) {
      var action, i, j, len, results1;
      results1 = [];
      for (i = j = 0, len = actions.length; j < len; i = ++j) {
        action = actions[i];
        results1.push((function(index) {
          return action._go(function(data) {
            countDown--;
            if (data instanceof Error) {
              cb(data);
              return cb = ignore;
            } else {
              results[index] = data;
              if (countDown === 0) {
                return cb(results);
              }
            }
          });
        })(i));
      }
      return results1;
    });
  };

  Action.allSuccess = function(actions) {
    var countDown, results;
    results = [];
    countDown = actions.length;
    return new Action(function(cb) {
      var action, i, j, len, results1;
      results1 = [];
      for (i = j = 0, len = actions.length; j < len; i = ++j) {
        action = actions[i];
        results1.push((function(index) {
          return action._go(function(data) {
            countDown--;
            results[index] = data;
            if (countDown === 0) {
              return cb(results);
            }
          });
        })(i));
      }
      return results1;
    });
  };

  Action.sequenceTry = function(args, monadicAction) {
    var a, countUp, length;
    length = args.length;
    countUp = 0;
    a = function(arg) {
      return monadicAction(arg).guard(function(e) {
        if (countUp++ < length) {
          return a(args[countUp]);
        } else {
          return new Error('Try limit reached');
        }
      });
    };
    if (length > 0) {
      return a(args[0]);
    } else {
      return Action.wrap(new Error('No argmuents for monadic'));
    }
  };

  Action.mkNodeAction = function(nodeAPI, arg) {
    return new Action(function(cb) {
      return nodeAPI(arg, function(err, data) {
        return cb(err ? err : data);
      });
    });
  };

  module.exports = Action;

}).call(this);
