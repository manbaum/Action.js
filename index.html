<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Action.js by winterland1989</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/winterland1989/Action.js">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/winterland1989/Action.js/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/winterland1989/Action.js/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Action.js</h1>
          <p>A sane way to write async code</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/winterland1989">winterland1989</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h1>
<a id="actionjs-a-sane-way-to-write-async-code" class="anchor" href="#actionjs-a-sane-way-to-write-async-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Action.js, a sane way to write async code</h1>

<p>Action.js offer a <a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">faster</a> and simpler(~200LOC) alternative to <a href="http://promisesaplus.com">Promise</a>, got 5 minutes?</p>

<h2>
<a id="understand-actionjs-in-5-minutes" class="anchor" href="#understand-actionjs-in-5-minutes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Understand Action.js in 5 minutes</h2>

<p>Suppose we want to solve the nest callback problem form scratch, there's an async function called <code>readFile</code>, and we want to use it to read <code>data.txt</code>, we have to supply a <code>callback</code> to it:</p>

<pre><code>readFile("data.txt", callback)
</code></pre>

<p>Instead we don't give a callback to it right now, we save this read action in a new <code>Action</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">Action</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">Action</span>(<span class="pl-smi">action1</span>) {
    <span class="pl-v">this</span>.<span class="pl-c1">action</span> <span class="pl-k">=</span> action1;
}

<span class="pl-k">var</span> readFileAction <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(
    <span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, cb);
    }
);</pre></div>

<p>We have following objects on our heap:</p>

<pre><code>+----------------+----------+
| readFileAction | .action  | 
+----------------+----+-----+
                      |
                      v
                +----------+---------------+
                | function | cb            |
                +----------+---------------+   
                | readFile("data.txt", cb) |
                +--------------------------+
</code></pre>

<p>Ok, now we must have a way to extract the action from our <code>readFileAction</code>, instead of using <code>readFileAction.action</code> directly, we write a function to accpet a callback, and pass this callback to the action inside our <code>readFileAction</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_go</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">action</span>(cb);
};
readFileAction._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
})</pre></div>

<p>You should understand what above <code>_go</code> does is equivalent to following:</p>

<div class="highlight highlight-source-js"><pre>readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
});</pre></div>

<p>Just with one difference, we seperate action creation(wrap <code>readFile</code> in <code>new Action</code>) and application(use <code>_go</code> to supply a callback), in fact we have successfully did a <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">CPS transformation</a>, we will talk about that later.</p>

<p>Now we want to chain more callbacks in Promise <code>then</code> style:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> self.<span class="pl-c1">action</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
            <span class="pl-k">return</span> _cb(_data);
        });
    });
};</pre></div>

<p>Let's break down <code>_next</code> a little here:</p>

<ul>
<li><p><code>_next</code> accept a callback <code>cb</code>, and return a new <code>Action</code>.</p></li>
<li><p>When the new <code>Action</code> fired, the original <code>Action</code>'s action will be fired first, and send the value to <code>cb</code>.</p></li>
<li><p>we save the <code>_data</code> produced by <code>cb</code>, and wait for a future <code>_cb</code>.</p></li>
</ul>

<p>With our <code>_next</code>, we can chain multiply callbacks and pass data between them:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> data.<span class="pl-c1">length</span>;
})
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is the length we obtain last step</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
    <span class="pl-k">return</span> length <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
})
._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is a Boolean</span>
    <span class="pl-k">if</span>(data){
        ...
    }
})</pre></div>

<p>If we want to present it with diagram, it should look like this:</p>

<pre><code>+----------------+----------+
| ActionTwo      | .action  | 
+----------------+----+-----+
                      |
                      v
                +----------+----------------+
                | function | cb_            |
                +----------+----------------+  
                | cb = function(data){      |
                |   console.log(data);      |
                |   return length &gt; 0       |
                | }                         |
           +--- + ActionOne.action(         |
           |    |   function(data){         |
           |    |     cb_(cb(data))         |
           |    |   });                     | 
           |    +---------------------------+
           |                            
           v       
+----------------+----------+            
| ActionOne      | .action  | 
+----------------+----+-----+
                      |
                      v
                +----------+----------------+
                | function | cb_            |
                +----------+----------------+  
                | cb = function(data){      |
                |   return data.length      |
                | }                         |
           +--- + readFileAction.action(    |
           |    |   function(data){         |
           |    |     cb_(cb(data))         |
           |    |   });                     | 
           |    +---------------------------+
           |           
           v          
+----------------+----------+
| readFileAction | .action  | 
+----------------+----+-----+
                      |
                      v
                +----------+---------------+
                | function | cb            |
                +----------+---------------+   
                | readFile("data.txt", cb) |
                +--------------------------+
</code></pre>

<p><code>ActionOne</code> and <code>ActionTwo</code> are <code>Action</code>s first and second <code>_next</code> returned respectively, Now if we give <code>ActionTwo</code> a <code>callback</code> with <code>_go</code>, the whole callback chain will be fired sequential.</p>

<p>Nice, we just use a simple class with only one field, two very simple functions, the callbacks are now written in a much more readable way, but we have a key problem to be solved yet: what if we want to nest async <code>Action</code>s inside an <code>Action</code>, it turn out with an adjusted <code>_next</code> function, we can handle that:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> self.<span class="pl-c1">action</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
            <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                <span class="pl-k">return</span> _data._go(_cb);
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> _cb(_data);
            }
        });
    });
};</pre></div>

<p>We use <code>instanceof Action</code> to check if a callback returns a <code>Action</code> or not, if an <code>Action</code> is returned, we fire it with callbacks in future:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">var</span> newFile <span class="pl-k">=</span> <span class="pl-c1">parse</span>(data);
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        readFile(newFile, cb);
    });
})
._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is the newFile's content</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data)
})</pre></div>

<p>Now we can say we have solved the callback hell problem! Well, actually just 50% of it.
Before we proceed another 50%, one important thing to keep in mind: <strong>an <code>Action</code> is not a <code>Promise</code>, it will not happen if you don't fire it with <code>_go</code>, and it can be fired multiple times, it's just a reference to a wrapped function</strong>:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(processOne)
._go(<span class="pl-en">console</span>.log)

<span class="pl-c">// after we do other things, or inside another request handler</span>
...

<span class="pl-c">// processTwo may receive different data since the file may change!</span>
readFileAction
._next(processTwo)
._go(<span class="pl-en">console</span>.log)</pre></div>

<p>I'll present <code>Action.freeze</code> in <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to give you Promise behavior when you need it, now let's attack another 50% of the callback hell issue.</p>

<h2>
<a id="error-handling" class="anchor" href="#error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error handling</h2>

<p>One biggest issue with <code>Promise</code> is that error handleing is somewhat magic and complex:</p>

<ul>
<li><p>It will eat your error sliently if you don't supply a <code>catch</code> at the end of the chain.</p></li>
<li><p>You have to use two different functions, <code>resolve</code> to pass value to the callbacks and <code>reject</code> to skip them, what will happen if you <code>throw</code> an <code>Error</code>, well, just the same as <code>reject</code></p></li>
</ul>

<p>What we can do to make it simpler? It's a complex problem, so we start solving it by simplify it: <strong>We use <code>Error</code> type as a special type to pass error information to the downstream</strong>, what does this mean?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> self.<span class="pl-c1">action</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
                <span class="pl-k">return</span> _cb(data);
            } <span class="pl-k">else</span> {
                <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
                <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                    <span class="pl-k">return</span> _data._go(_cb);
                } <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> _cb(_data);
                }
            }
        });
    });
};</pre></div>

<p>Here, let me present the final version of our <code>next</code> function, comparing to <code>_next</code> we write before, can you see what's the different? It still reture a new <code>Action</code>, when it fired, the original action are called, and we checked if the data are <code>instanceof Error</code>, if it's not, everything as usual, we feed it to <code>cb</code> that <code>next</code> received, but if it's an <code>Error</code>, we pass it to a future <code>_cb</code>, which we don't have now.</p>

<p>Symmetrically, we have to define a function that special deal with <code>Errors</code>, and let normal values pass:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">guard</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> self.<span class="pl-c1">action</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
           <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
                <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                    <span class="pl-k">return</span> _data._go(_cb);
                } <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> _cb(_data);
                }
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> _cb(data);
            }
        });
    });
};</pre></div>

<p>This time, we know the <code>cb</code> that <code>guard</code> received are prepared for <code>Error</code> values, so we flip the logic, since it's just a flipped version of <code>next</code>, you can return an <code>Action</code> if your need some async code to deal with the <code>Error</code>.</p>

<p>Following code demonstrate how to use our <code>next</code> and <code>guard</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// see how to pass an Error to downstream, not reject, not throw, just return</span>
            cb(err);
        }<span class="pl-k">else</span>{

            cb(data);
        }
    });
})
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> processData(data);
})
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        processDataAsync(data, cb);
    })
})
.<span class="pl-c1">next</span>(
    <span class="pl-k">try</span>{
        <span class="pl-k">return</span> someProcessMayWentWrong(data);
    }<span class="pl-k">catch</span>(e){
        <span class="pl-c">// same as above, we return the error</span>
        <span class="pl-k">return</span> e;
    }
}))
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// This process will be skip if previous step pass an Error</span>
    <span class="pl-k">return</span> anotherProcess(data);
})
.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>){
    <span class="pl-c">// This process will be skip if there's no Errors</span>
    <span class="pl-k">return</span> processError(e);
});
._go(<span class="pl-en">console</span>.log);
</pre></div>

<p>The final result will be produced by <code>anotherProcess</code> if <code>someProcessMayWentWrong</code> didn't go wrong, or produced by <code>processError</code> otherwise.</p>

<p>You can place <code>guard</code> in the middle of the chain, all <code>Errors</code> before it will be handled by it, and the value it produced, will be passed to the rest of the chain.</p>

<p>So, what if the use didn't supply a <code>guard</code>? Well, since use have to supply a callback to the <code>_go</code>, they can check if the callback they supplied received an <code>Error</code> or not like this:</p>

<div class="highlight highlight-source-js"><pre>apiReturnAction(<span class="pl-s"><span class="pl-pds">'</span>...<span class="pl-pds">'</span></span>)._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error){
        <span class="pl-c">//handle error here</span>
        ...
    } <span class="pl-k">else</span> {
        <span class="pl-c">// process data here</span>
        ...
    }
});
</pre></div>

<p>Yeah, it does work(and sometimes very useful), but we don't want to force our user to write like above, and we should throw <code>Error</code> in case user didn't <code>guard</code> them, so here let me present the final version of <code>go</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">go</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">action</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
        <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
            <span class="pl-k">throw</span> data;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (cb <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> cb(data);
        }
    });
};
</pre></div>

<p>Now user can omit the callback, and if user don't guard <code>Error</code>s, we will yell at them when <code>Error</code> occurs!</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// suppose we got an Error here</span>
            cb(err);
        }<span class="pl-k">else</span>{

            cb(data);
        }
    });
})
.<span class="pl-c1">go</span>() <span class="pl-c">// The Error will be throw!</span>
</pre></div>

<p>Finally, to ease error management, and to attack the <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#2-unsupported-syntax">v8 optimization problems</a>. We recommand use <code>Action.safe</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// this small function minimize v8 try-catch overhead</span>
<span class="pl-c">// and make attaching custom Error easy</span>
<span class="pl-c1">Action</span>.<span class="pl-en">safe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">fn</span>) {
    <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
        <span class="pl-k">try</span> {
            <span class="pl-k">return</span> fn(data);
        } <span class="pl-k">catch</span> (_error) {
            <span class="pl-k">return</span> err;
        }
    };
};</pre></div>

<p>And use <code>safe</code> wrap your <code>someProcessMayWentWrong</code> like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> safe <span class="pl-k">=</span> Action.safe;
<span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// see how to pass an Error to downstream, not reject, not throw, just return</span>
            cb(err);
        }<span class="pl-k">else</span>{
            cb(data);
        }
    });
})
.<span class="pl-c1">next</span>(
    safe( <span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">"</span>PROCESS_ERROR_XXX: process xxx failed when xxx<span class="pl-pds">"</span></span>)
        , someProcessMayWentWrong)
)
.<span class="pl-c1">next</span>(...)
.<span class="pl-c1">next</span>(...)
.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>){
    <span class="pl-k">if</span> (e.message.<span class="pl-c1">indexOf</span>(<span class="pl-s"><span class="pl-pds">'</span>ENOENT<span class="pl-pds">'</span></span>) <span class="pl-k">===</span> <span class="pl-c1">0</span>){
        ...
    }
    <span class="pl-k">if</span> (e.message.<span class="pl-c1">indexOf</span>(<span class="pl-s"><span class="pl-pds">'</span>PROCESS_ERROR_XXX<span class="pl-pds">'</span></span>) <span class="pl-k">===</span> <span class="pl-c1">0</span> ){
        ...
    }
})
.<span class="pl-c1">go</span>()
</pre></div>

<p>That's all core functions of <code>Action</code> is going to give you, hope you enjoy my solution :), Check <a href="https://github.com/winterland1989/Action.js/wiki/API-document">API doc</a> for more interesting things like <code>Action.parallel</code>, <code>Action.race</code>, <code>Action.sequence</code> and <code>Action.retry</code>, It's also highly recommend to read <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to get a deeper understanding.</p>

<h1>
<a id="faq" class="anchor" href="#faq" aria-hidden="true"><span class="octicon octicon-link"></span></a>FAQ</h1>

<h2>
<a id="why-you-claim-action-are-faster-than-promise" class="anchor" href="#why-you-claim-action-are-faster-than-promise" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why you claim <code>Action</code> are faster than <code>Promise</code>?</h2>

<p>Because it simply do less work:</p>

<ul>
<li>It doesn't maintain a internal state</li>
<li>It just have a single field</li>
<li>It just add a redirect call to original callback, and some type checking</li>
</ul>

<p>I even be amazed it can achieve so much functionality with such short code myself, see <a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">Benchmark</a> youself.</p>

<h2>
<a id="why-following-code-doesnt-work" class="anchor" href="#why-following-code-doesnt-work" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why following code doesn't work?</h2>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> fileA <span class="pl-k">=</span> readFileAction
.<span class="pl-c1">go</span>(processOne)

fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()</pre></div>

<p>Well, read <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to get a detailed answer, tl,dr... here is the short answer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// readFile now and return a Action, this function won't block</span>
<span class="pl-k">var</span> fileA <span class="pl-k">=</span> Action.freeze(readFileAction.<span class="pl-c1">next</span>(processOne))

<span class="pl-c">// now fileA will always have the same content and file will never be read again.</span>
fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()

<span class="pl-c">// processTwo will receive the same content</span>
fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()</pre></div>

<p>If you want have a Promise behavior(fire and memorize), use <code>Action.freeze</code>, <code>go</code> won't return a new <code>Action</code>.</p>

<h2>
<a id="when-to-use-this-library" class="anchor" href="#when-to-use-this-library" aria-hidden="true"><span class="octicon octicon-link"></span></a>When to use this library?</h2>

<p>With <code>Promise</code> added to ES6 and ES7 <code>async/await</code> proposal, you muse ask, why another library to the same trick again?, well, i can add generator support myself with something like <code>Action.async</code>, but i guess <code>Action</code> will never be part of the language, so i didn't, and i can see future will be full of <code>async</code> functions all over the place, so use this library if you:</p>

<ul>
<li>Have a FP background(can't you see all i have done is porting the <code>Cont</code> monad from Haskell?)</li>
<li>Want raw speed, <code>Action.js</code> guarantee speed close to handroll callbacks, just much cleaner.</li>
<li>Want different sementics, with <code>Promise</code>, you just can't reuse your callback chain, we have to create a new <code>Promise</code>, with <code>Action</code>, just <code>go</code> again. </li>
</ul>

<p>Consider following code:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-en">retry</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">times</span>, <span class="pl-smi">action</span>) {
    <span class="pl-k">var</span> a;
    <span class="pl-k">return</span> a <span class="pl-k">=</span> action.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>) {
        <span class="pl-k">if</span> (times<span class="pl-k">--</span> <span class="pl-k">!==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> a;
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">'</span>RETRY_ERROR: Retry limit reached<span class="pl-pds">'</span></span>);
        }
    });
};</pre></div>

<p><code>Action.js</code> let you do <a href="https://www.haskell.org/haskellwiki/Recursion_in_a_monad">monadic recursion</a>, while <code>Promise</code> can't.</p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
