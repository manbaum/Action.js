<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Action.js by winterland1989</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Action.js</h1>
        <p>A sane way to write async code</p>

        <p class="view"><a href="https://github.com/winterland1989/Action.js">View the Project on GitHub <small>winterland1989/Action.js</small></a></p>


        <ul>
          <li><a href="https://github.com/winterland1989/Action.js/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/winterland1989/Action.js/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/winterland1989/Action.js">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="actionjs-a-fast-small-full-feature-async-library" class="anchor" href="#actionjs-a-fast-small-full-feature-async-library" aria-hidden="true"><span class="octicon octicon-link"></span></a>Action.js, a fast, small, full feature async library</h1>

<ul>
<li><a href="#FAQ">FAQ</a></li>
<li><a href="#Changelog">Changelog</a></li>
<li><a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">Benchmark</a></li>
<li><a href="https://github.com/winterland1989/Action.js/wiki/API-document">API document</a></li>
<li>
<p>Usage: </p>

<ul>
<li>
<code>npm i action-js</code> and <code>var Action = require('action-js')</code>.</li>
<li>Clone this repo and use <code>Action.js</code> and <code>ajaxHelper.js</code> with AMD or CMD loader, bundler.</li>
<li>Add a script tag and use <code>window.Action</code>.</li>
</ul>
</li>
<li>
<p>Highlights:</p>

<ul>
<li>
<a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">Blazing fast</a> and extremly small(4.2k/minified 1.4k/gzipped)</li>
<li>Full feature APIs like <code>retry</code>, <code>parallel</code>, <code>race</code>, <code>sequence</code> and more.</li>
<li>
<a href="https://github.com/winterland1989/Action.js/wiki/Return-value-of-go">Cancellable</a> and <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">retriable</a> semantics.</li>
<li>
<code>Action.co</code> to work with generator functions.</li>
<li>
<a href="https://github.com/winterland1989/Action.js/wiki/Signal-And-Pump">Signal and pump</a> provides easy and composable async UI management(form validation...).</li>
<li>Provide <code>ajax</code>, <code>jsonp</code> for front-end usage, check <code>ajaxHelper.js</code> and <a href="https://github.com/winterland1989/Action.js/wiki/ajaxHelpers-API-document">ajaxHelpers API doc</a>.</li>
</ul>
</li>
</ul>

<h2>
<a id="what-is-action" class="anchor" href="#what-is-action" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is <code>Action</code>
</h2>

<p>Interested? <code>Action</code> is a fast and clean alternative to both <code>Promise</code> and <code>Observable</code>ï¼ŒIts core is an extremly simple javascript class:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">Action</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">go</span>) {
    <span class="pl-v">this</span>._go <span class="pl-k">=</span> go;
}</pre></div>

<p>We construct an <code>Action</code> by passing a function which consume a callback(aka. contination), take <code>fs.readFile</code> as an example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// suppose this readFile never fail</span>
<span class="pl-c">// we will talk error handleing later</span>
<span class="pl-k">var</span> readFileAction <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    fs.readFile(<span class="pl-s"><span class="pl-pds">'</span>data.txt<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        cb(data);
    })
});</pre></div>

<p>Now if we provide a callback to <code>readFileAction._go</code>:</p>

<div class="highlight highlight-source-js"><pre>readFileAction._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
})</pre></div>

<p>The callback chain will be fired, it's equivalent to following code:</p>

<div class="highlight highlight-source-js"><pre>readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
});</pre></div>

<p>With one difference, <code>Action</code> seperate contination creation(wrap <code>readFile</code> in <code>new Action</code>) and application(supply a callback to <code>_go</code>), that's the core idea of <code>Action</code>, <strong>an Action always wrap a contination inside</strong>. </p>

<p>Now we can add a method to compose another callback with this contination:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
            <span class="pl-k">return</span> _cb(_data);
        });
    });
};</pre></div>

<p>Let's break down <code>_next</code> a little here:</p>

<ul>
<li><p><code>_next</code> accept a callback <code>cb</code>, and return a new <code>Action</code>.</p></li>
<li><p>When the new <code>Action</code> fired with <code>_cb</code>, the original <code>Action</code>'s action will be fired first, and send the value to <code>cb</code>.</p></li>
<li><p>We apply <code>cb</code> with <code>data</code> from the original <code>Action</code>, then send the <code>_data</code> produced by <code>cb(data)</code> to <code>_cb</code>.</p></li>
<li><p>The order is (original <code>Action</code>'s <code>_go</code>) --&gt; (<code>cb</code> which <code>_next</code> received) --&gt; (<code>_cb</code> we give to our new <code>Action</code>).</p></li>
<li><p>Since we haven't fired our new <code>Action</code> yet, we haven't got the <code>_cb</code>, the whole callback chain is saved in our new <code>Action</code>.</p></li>
</ul>

<p>With our <code>_next</code>, we can chain multiply callbacks and pass data between them:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> data.<span class="pl-c1">length</span>;
})
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is the length we obtain last step</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
    <span class="pl-k">return</span> length <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
})
._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is a Boolean</span>
    <span class="pl-k">if</span>(data){
        ...
    }
})</pre></div>

<p>Each <code>_next</code> return a new <code>Action</code>, now if we give the final <code>Action</code> a callback with <code>_go</code>, the whole callback chain will be fired sequential.</p>

<p>Nice, we just use a very simple class, one very simple functions, the callbacks are written in a much more readable way now, but we have a key problem to be solved yet: what if we want to nest async <code>Action</code> inside an <code>Action</code>? Turn out with a little modification to our <code>_next</code> function, we can handle that:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
            <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                <span class="pl-k">return</span> _data._go(_cb);
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> _cb(_data);
            }
        });
    });
};</pre></div>

<p>This's the core of composable contination, We use <code>instanceof Action</code> to check if <code>cb</code> returns an <code>Action</code> or not, if an <code>Action</code> is returned, we fire it with <code>_cb</code>, the callback which our new <code>Action</code> will going to receive:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">var</span> newFile <span class="pl-k">=</span> <span class="pl-c1">parse</span>(data);
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        readFile(newFile, cb);
    });
})
._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is the newFile's content</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data)
})</pre></div>

<p>Now we have solved the callback hell problem! Well, actually just 50% of it.
Before we proceed another 50%, one important thing to keep in mind: <strong>an <code>Action</code> is not a <code>Promise</code>, it will not happen if you don't pass a callback to <code>_go</code>, and it can be fired multiple times, it's just a reference to a wrapped contination</strong>:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(processOne)
._go(<span class="pl-en">console</span>.log)

<span class="pl-c">// after we do other things, or inside another request handler</span>
...

<span class="pl-c">// processTwo may receive different data since the file may change!</span>
readFileAction
._next(processTwo)
._go(<span class="pl-en">console</span>.log)</pre></div>

<p>I'll present <code>Action.freeze</code> in <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to give you <code>Promise</code> behavior when you need it, now let's attack another 50% of the callback hell issue.</p>

<h2>
<a id="error-handling" class="anchor" href="#error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error handling</h2>

<p>One biggest issue with <code>Promise</code> is that error handleing is somewhat magic and complex:</p>

<ul>
<li><p>It will eat your error sliently if you don't supply a <code>catch</code> at the end of the chain.</p></li>
<li><p>You have to use two different functions, <code>resolve</code> to pass value to the callbacks and <code>reject</code> to skip them, what will happen if you <code>throw</code> an <code>Error</code>, well, just the same as <code>reject</code>.</p></li>
<li><p>You lost the ability to break your program by throwing, sometime you do need it.</p></li>
</ul>

<p>What we can do to make it simpler? It's a complex problem, we start solving it by simplify it: <strong>Action.js use <code>Error</code> type as a special type to pass error information to the downstream</strong>, what does this mean?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
                <span class="pl-k">return</span> _cb(data);
            } <span class="pl-k">else</span> {
                <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
                <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                    <span class="pl-k">return</span> _data._go(_cb);
                } <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> _cb(_data);
                }
            }
        });
    });
};</pre></div>

<p>Here, let me present the final version of our <code>next</code> function, comparing to <code>_next</code> we write before:</p>

<ul>
<li><p>It still reture a new <code>Action</code>, when it fired, the original action are called.</p></li>
<li><p>We checked if the <code>data</code> coming from upstream is <code>instanceof Error</code>, if it's not, everything as usual, we feed it to <code>cb</code> that <code>next</code> received.</p></li>
<li><p>But if it's an <code>Error</code>, we skip <code>cb</code>, pass it to <code>_cb</code> which we don't have now.</p></li>
</ul>

<p><code>next</code> ensure the <code>cb</code> it received, <strong>will never receive an <code>Error</code></strong>, we just skip <code>cb</code> and pass <code>Error</code> downstream, symmetrically, we define a function which only deal with <code>Error</code>, and let normal values pass:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">guard</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
           <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
                <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                    <span class="pl-k">return</span> _data._go(_cb);
                } <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> _cb(_data);
                }
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> _cb(data);
            }
        });
    });
};</pre></div>

<p>This time, the <code>cb</code> that <code>guard</code> received are prepared for <code>Error</code> values, so we flip the logic, you can also return an <code>Action</code> if your need some async code to deal with the <code>Error</code>.</p>

<p>Following code demonstrate how to use our <code>next</code> and <code>guard</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// see how to pass an Error to downstream</span>
            <span class="pl-c">// not reject, not throw, just pass it on, let it go</span>
            cb(err);
        }<span class="pl-k">else</span>{
            cb(data);
        }
    });
})
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// sync process</span>
    <span class="pl-k">return</span> processData(data);
})
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// async process</span>
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        processDataAsync(data, cb);
    })
})
.<span class="pl-c1">next</span>(
    <span class="pl-k">try</span>{
        <span class="pl-k">return</span> someProcessMayWentWrong(data);
    }<span class="pl-k">catch</span>(e){
        <span class="pl-c">// same as above, we return the error to pass it on</span>
        <span class="pl-k">return</span> e;
    }
}))
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// This process will be skip if previous steps pass an Error</span>
    <span class="pl-k">return</span> anotherProcess(data);
})
.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>){
    <span class="pl-c">// This process will be skip if there's no Errors</span>
    <span class="pl-k">return</span> processError(e);
});
._go(<span class="pl-en">console</span>.log);
</pre></div>

<p>The final result will be produced by <code>anotherProcess</code> if <code>someProcessMayWentWrong</code> didn't go wrong and <code>readFile</code> didn't fail, otherwise it will be produced by <code>processError</code>.</p>

<p>You can place <code>guard</code> in the middle of the chain, all <code>Errors</code> before it will be handled by it, and the value it produced, sync or async, will be passed to the rest of the chain.</p>

<p>What if we don't supply a <code>guard</code>? Since we have to supply a callback to <code>_go</code>, we can check if the final result is an <code>Error</code> or not like this:</p>

<div class="highlight highlight-source-js"><pre>apiReturnAction(<span class="pl-s"><span class="pl-pds">'</span>...<span class="pl-pds">'</span></span>)._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error){
        <span class="pl-c">//handle error here</span>
        ...
    } <span class="pl-k">else</span> {
        <span class="pl-c">// process data here</span>
        ...
    }
});
</pre></div>

<p>Yeah, it does work, and often you want it work in this way, but:</p>

<ul>
<li><p>sometime we don't want to supply a <code>cb</code>.</p></li>
<li><p>we should throw <code>Error</code> in case user didn't <code>guard</code> them.</p></li>
</ul>

<p>So here let me present the final version of <code>go</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">go</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">return</span> <span class="pl-v">this</span>._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
        <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
            <span class="pl-k">throw</span> data;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (cb <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> cb(data);
        }
    });
};
</pre></div>

<p>Now user can omit the callback, and if user don't guard <code>Error</code>s, we will yell at them when <code>Error</code> occurs!</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// suppose we got an Error here</span>
            cb(err);
        }<span class="pl-k">else</span>{

            cb(data);
        }
    });
})
.<span class="pl-c1">go</span>() <span class="pl-c">// The Error will be thrown!</span>
</pre></div>

<p>Finally, to ease error management, and attack the <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#2-unsupported-syntax">v8 optimization problems</a>. We recommand using <code>Action.safe</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// this small function minimize v8 try-catch overhead</span>
<span class="pl-c">// and make attaching custom Error easy</span>
<span class="pl-c1">Action</span>.<span class="pl-en">safe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">fn</span>) {
    <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
        <span class="pl-k">try</span> {
            <span class="pl-k">return</span> fn(data);
        } <span class="pl-k">catch</span> (_error) {
            <span class="pl-k">return</span> err;
        }
    };
};</pre></div>

<p>Use <code>safe</code> wrap your <code>someProcessMayWentWrong</code> like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> safe <span class="pl-k">=</span> Action.safe;
<span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    ...
})
.<span class="pl-c1">next</span>(
    safe(<span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">"</span>PROCESS_ERROR_XXX: process xxx failed when xxx<span class="pl-pds">"</span></span>)
        , someProcessMayWentWrong)
)
.<span class="pl-c1">next</span>(...)
.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>){
    <span class="pl-k">if</span> (e.message.<span class="pl-c1">indexOf</span>(<span class="pl-s"><span class="pl-pds">'</span>ENOENT<span class="pl-pds">'</span></span>) <span class="pl-k">===</span> <span class="pl-c1">0</span>){
        ...
    }
    <span class="pl-k">if</span> (e.message.<span class="pl-c1">indexOf</span>(<span class="pl-s"><span class="pl-pds">'</span>PROCESS_ERROR_XXX<span class="pl-pds">'</span></span>) <span class="pl-k">===</span> <span class="pl-c1">0</span> ){
        ...
    }
})
.<span class="pl-c1">go</span>()
</pre></div>

<p>That's all core functions of <code>Action</code>, but it's much more powerful than first look! make sure you read:</p>

<ul>
<li><p><a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to get a deeper understanding.</p></li>
<li><p><a href="https://github.com/winterland1989/Action.js/wiki/Return-value-of-go">Return value of go</a> to learn how to cancel an <code>Action</code>.</p></li>
<li><p><a href="https://github.com/winterland1989/Action.js/wiki/Signal-and-pump">Signal and pump</a> to see how <code>Action</code> making async UI management easy.</p></li>
<li><p><a href="https://github.com/winterland1989/Action.js/wiki/API-document">API doc</a> for interesting things like <code>Action.parallel</code>, <code>Action.race</code>, <code>Action.sequence</code> and <code>Action.retry</code>.</p></li>
<li><p><a href="https://github.com/winterland1989/Action.js/wiki/ajaxHelpers-API-document">ajaxHelpers API doc</a> for front-end needs like <code>ajax</code>, <code>jsonp</code> and <code>parseParam/buildParam</code>.</p></li>
</ul>

<h1>
<a id="faq" class="anchor" href="#faq" aria-hidden="true"><span class="octicon octicon-link"></span></a>FAQ<a name="FAQ"></a>
</h1>

<h2>
<a id="when-to-use-this-library" class="anchor" href="#when-to-use-this-library" aria-hidden="true"><span class="octicon octicon-link"></span></a>When to use this library?</h2>

<p>With <code>Promise</code> added to ES6 and ES7 <code>async/await</code> proposal, one must ask, why another library to do the same things again?</p>

<p>Because <code>Action</code> is not <code>Promise</code>, It's a faster, simpler and full feature alternative comes with more flexible semantics. Actually <code>Action</code> have a <a href="https://github.com/winterland1989/Action.js/blob/master/Action.coffee#L205">very elegant <code>Action.co</code> implementation</a> to work with generators, nevertheless, use this library if you:</p>

<ul>
<li><p>Want something small, fast and memory effient in browser.</p></li>
<li><p>Want to manage complex async UI, read <a href="https://github.com/winterland1989/Action.js/wiki/Signal-and-pump">Signal and pump</a> to get a modular solution to async UI management.</p></li>
<li><p>Want manage cancellable actions, read the <a href="https://github.com/winterland1989/Action.js/wiki/Return-value-of-go">Return value of go</a> to get an elegant solution to cancellable actions.</p></li>
<li><p>Want a different sementics, with <code>Promise</code>, you just can't reuse your callback chain, you have to create a new <code>Promise</code>, with <code>Action</code>, just <code>go</code> again, never waste memory on GC. </p></li>
<li><p>Want to control exactly when the action will run, with <code>Promise</code>, all action run in next tick, While with <code>Action</code>, action runs when you call <code>go</code>, <code>_go</code> or <code>Action.freeze</code>.</p></li>
<li><p>Want raw speed, this is somehow not really an issue, most of the time <code>Promise</code> or <code>Action</code> won't affect that much, nevertheless, <code>Action.js</code> can guarantee speed close to handroll callbacks in any runtime, just much cleaner.</p></li>
</ul>

<p>If you have a FP background, you must find all i have done is porting the <code>Cont</code> monad from Haskell, and i believe you have divided your program into many composable functions already, just connect them with <code>next</code>.</p>

<p>The semantics of <code>Action</code> also fit varieties situations like animation and interactive UI, it's far more suitable than <code>Promise</code> in these situations.</p>

<h2>
<a id="what-makes-action-fast" class="anchor" href="#what-makes-action-fast" aria-hidden="true"><span class="octicon octicon-link"></span></a>What makes <code>Action</code> fast?</h2>

<p>Check out <a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">Benchmark</a>, even use bluebird's benchmark suit, which heavily depend on library's <a href="https://github.com/petkaantonov/bluebird/blob/master/src/promisify.js#L124">promisify</a> implementation, <code>Action</code> can match bluebird's performance.</p>

<p>Generally speaking, <code>Action</code> simply does less work:</p>

<ul>
<li><p>It doesn't maintain any internal state.</p></li>
<li><p>It just have a single field, which is a reference to a function.</p></li>
<li><p>It just add a redirect call to original callback, and some type checking.</p></li>
</ul>

<h2>
<a id="why-following-code-doesnt-work" class="anchor" href="#why-following-code-doesnt-work" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why following code doesn't work?</h2>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> fileA <span class="pl-k">=</span> readFileAction
.<span class="pl-c1">go</span>(processOne)

<span class="pl-c">// Error, fileA is not an Action anymore</span>
fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()</pre></div>

<p>Well, read <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> and <a href="https://github.com/winterland1989/Action.js/wiki/Return-value-of-go">Return value of go</a> to get a detailed answer, tl,dr... here is the short answer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// readFile now and return a Action, this function won't block</span>
<span class="pl-k">var</span> fileA <span class="pl-k">=</span> Action.freeze(readFileAction.<span class="pl-c1">next</span>(processOne))

<span class="pl-c">// now fileA will always have the same content</span>
<span class="pl-c">// and file will never be read again.</span>
fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()

<span class="pl-c">// processTwo will receive the same content</span>
fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()</pre></div>

<p>If you want have a <code>Promise</code> behavior(fire and memorize), use <code>Action.freeze</code>, <code>go</code> won't return a new <code>Action</code>, instead <code>go</code> return a cancel handler if underline action can be cancelled.</p>

<h2>
<a id="how-can-i-send-an-error-to-downstreams-next" class="anchor" href="#how-can-i-send-an-error-to-downstreams-next" aria-hidden="true"><span class="octicon octicon-link"></span></a>How can i send an <code>Error</code> to downstream's <code>next</code>
</h2>

<p>No, you can't, however, you can receive <code>Error</code> from upstream use <code>_next</code>, <code>_go</code> or <code>guard</code>. or you can wrap the <code>Error</code> in an <code>Array</code> like <code>[e]</code>, it's a very rare situation one want to process a <code>Error</code> value like normal values.</p>

<p>The choice of using <code>Error</code> to skip <code>next</code> and hit <code>guard</code> is not arbitrary, instead of creating an <code>ActionError</code> class, use <code>Error</code> unify type with system runtime, and providing callstack information. And you can now break your program by throwing an Error if you really want to.</p>

<h1>
<a id="changelog" class="anchor" href="#changelog" aria-hidden="true"><span class="octicon octicon-link"></span></a>Changelog<a name="Changelog"></a>
</h1>

<p>v3.0.0
Seperate ajax related stuff into <code>ajaxHelper.js</code>.</p>

<p>v2.4.2
Make <code>prototype.go</code> default to id function if no callback is provided.</p>

<p>v2.4.1
Fix a <code>Action.fuseSignal</code> bug.</p>

<p>v2.4.0
Add <code>Action.signal</code> and <code>Action.fuseSignal</code> to ease async UI management.</p>

<p>v2.3.0
Now when you construct an <code>Action</code>, the <code>this</code> variable inside the contination will be the <code>Action</code> instance.</p>

<p>v2.2.0
<code>Action.join</code>, <code>Action.parallel</code>, <code>Action.race</code> now return an <code>Array</code> of cancel handler when the composed <code>Action</code> fired, you can now cancel them with ease. </p>

<p>v2.1.1
Fix a bug of <code>Action.parallel</code>, add test. </p>

<p>v2.1.0
Change <code>Action.co</code> into more async-await style, you can use try-catch to catch <code>Error</code>s now.  </p>

<p>v2.0.0
Update doc, Remove <code>gapRetry</code>, since it's just a <code>retry</code> compose <code>delay</code>. </p>

<p>v1.4.1
Run bluebird benchmark, add some optimization.</p>

<p>v1.4.0
Add Action.co, fix Action.join typos, test cover 100% agian.</p>

<p>v1.3.0
Add Action.join, optimized internal</p>

<p>v1.2.4
Improve makeNodeAction</p>

<p>v1.2.3
Fix responseType related.</p>

<p>v1.2.2
Auto add header based on data type.</p>

<p>v1.2.1
Clear some error types.</p>

<p>v1.2.0
add <code>param</code>, <code>jsonp</code> and <code>ajax</code> for front-end usage.</p>

<h1>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h1>

<p>The MIT License (MIT)</p>

<p>Copyright (c) 2015 Winterland</p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/winterland1989">winterland1989</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
