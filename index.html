<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Action.js by winterland1989</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Action.js</h1>
        <p>A sane way to write async code</p>

        <p class="view"><a href="https://github.com/winterland1989/Action.js">View the Project on GitHub <small>winterland1989/Action.js</small></a></p>


        <ul>
          <li><a href="https://github.com/winterland1989/Action.js/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/winterland1989/Action.js/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/winterland1989/Action.js">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="actionjs-a-sane-way-to-write-async-code" class="anchor" href="#actionjs-a-sane-way-to-write-async-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Action.js, a sane way to write async code</h1>

<ul>
<li><a href="#FAQ">FAQ</a></li>
<li><a href="#Changelog">Changelog</a></li>
<li><a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">Benchmark</a></li>
<li><a href="https://github.com/winterland1989/Action.js/wiki/API-document">API document</a></li>
<li>
<p>Usage: </p>

<ul>
<li>
<code>npm i action-js</code> and <code>var Action = require('action-js')</code>.</li>
<li>
<code>git clone https://github.com/winterland1989/Action.js.git</code> and <code>var Action = require('Action.js')</code>.</li>
<li>Add a script tag and use <code>window.Action</code>.</li>
</ul>
</li>
<li>
<p>Highlights:</p>

<ul>
<li>
<a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">Faster</a> and simpler(~1kB minified gzipped)</li>
<li>Full control capability with <code>retry</code>, <code>parallel</code>, <code>race</code>, <code>sequence</code> and more.</li>
<li>
<a href="https://github.com/winterland1989/Action.js/wiki/Return-value-of-go">Cancellable</a> and <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">retriable</a> semantics.</li>
<li>Bundled with <code>ajax</code>, <code>jsonp</code> for front-end usage.</li>
</ul>
</li>
</ul>

<h2>
<a id="understand-actionjs" class="anchor" href="#understand-actionjs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Understand Action.js</h2>

<p>Suppose we want to solve the nest callback problem form scratch, there's an async function called <code>readFile</code>, and we want to use it to read <code>data.txt</code>, we have to supply a <code>callback</code> to it:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// suppose this simple readFile never fail</span>
readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
});</pre></div>

<p>Instead we don't give a callback(the <code>console.log</code>) to it right now, we save this read action in a new <code>Action</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">Action</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">go</span>) {
    <span class="pl-v">this</span>._go <span class="pl-k">=</span> go;
}

<span class="pl-k">var</span> readFileAction <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(
    <span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, cb);
    }
);</pre></div>

<p>Ok, now we must have a way to extract the action from our <code>readFileAction</code>, let's using <code>readFileAction._go</code> directly:</p>

<div class="highlight highlight-source-js"><pre>readFileAction._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
})</pre></div>

<p>What above does is equivalent to what we write at beginning, right?:</p>

<div class="highlight highlight-source-js"><pre>readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
});</pre></div>

<p>Just with one difference, we seperate action creation(wrap <code>readFile</code> in <code>new Action</code>) and application(supply a callback to <code>_go</code>), Now we want to chain more callbacks in Promise <code>then</code> style:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
            <span class="pl-k">return</span> _cb(_data);
        });
    });
};</pre></div>

<p>Let's break down <code>_next</code> a little here:</p>

<ul>
<li><p><code>_next</code> accept a callback <code>cb</code>, and return a new <code>Action</code>.</p></li>
<li><p>When the new <code>Action</code> fired with <code>_cb</code>, the original <code>Action</code>'s action will be fired first, and send the value to <code>cb</code>.</p></li>
<li><p>We apply <code>cb</code> with <code>data</code> from the original <code>Action</code></p></li>
<li><p>Then we send the <code>_data</code> produced by <code>cb(data)</code> to <code>_cb</code>.</p></li>
<li><p>The order is (original <code>Action</code>'s <code>_go</code>) --&gt; (<code>cb</code> which <code>_next</code> received) --&gt; (<code>_cb</code> we give to our new <code>Action</code>).</p></li>
<li><p>Since we haven't fired our new <code>Action</code> yet, we haven't send the <code>_cb</code>, the whole callback chain is saved in our new <code>Action</code>.</p></li>
</ul>

<p>With our <code>_next</code>, we can chain multiply callbacks and pass data between them:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> data.<span class="pl-c1">length</span>;
})
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is the length we obtain last step</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
    <span class="pl-k">return</span> length <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
})
._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is a Boolean</span>
    <span class="pl-k">if</span>(data){
        ...
    }
})</pre></div>

<p>Each <code>_next</code> return a new <code>Action</code>, Now if we give the final <code>Action</code> a callback with <code>_go</code>, the whole callback chain will be fired sequential.</p>

<p>Nice, we just use a simple class with only one field, one very simple functions, the callbacks are written in a much more readable way now, but we have a key problem to be solved yet: what if we want to nest async <code>Action</code> inside an <code>Action</code>? Turn out with a little modification to our <code>_next</code> function, we can handle that:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
            <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                <span class="pl-k">return</span> _data._go(_cb);
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> _cb(_data);
            }
        });
    });
};</pre></div>

<p>We use <code>instanceof Action</code> to check if <code>cb</code> returns an <code>Action</code> or not, if an <code>Action</code> is returned, we fire it with <code>_cb</code>, the callback which our new <code>Action</code> will going to receive:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">var</span> newFile <span class="pl-k">=</span> <span class="pl-c1">parse</span>(data);
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        readFile(newFile, cb);
    });
})
._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is the newFile's content</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data)
})</pre></div>

<p>Now we can say we have solved the callback hell problem! Well, actually just 50% of it.
Before we proceed another 50%, one important thing to keep in mind: <strong>an <code>Action</code> is not a <code>Promise</code>, it will not happen if you don't fire it with <code>_go</code>, and it can be fired multiple times, it's just a reference to a wrapped function</strong>:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(processOne)
._go(<span class="pl-en">console</span>.log)

<span class="pl-c">// after we do other things, or inside another request handler</span>
...

<span class="pl-c">// processTwo may receive different data since the file may change!</span>
readFileAction
._next(processTwo)
._go(<span class="pl-en">console</span>.log)</pre></div>

<p>I'll present <code>Action.freeze</code> in <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to give you <code>Promise</code> behavior when you need it, now let's attack another 50% of the callback hell issue.</p>

<h2>
<a id="error-handling" class="anchor" href="#error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error handling</h2>

<p>One biggest issue with <code>Promise</code> is that error handleing is somewhat magic and complex:</p>

<ul>
<li><p>It will eat your error sliently if you don't supply a <code>catch</code> at the end of the chain.</p></li>
<li><p>You have to use two different functions, <code>resolve</code> to pass value to the callbacks and <code>reject</code> to skip them, what will happen if you <code>throw</code> an <code>Error</code>, well, just the same as <code>reject</code>.</p></li>
</ul>

<p>What we can do to make it simpler? It's a complex problem, we start solving it by simplify it: <strong>Action.js use <code>Error</code> type as a special type to pass error information to the downstream</strong>, what does this mean?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
                <span class="pl-k">return</span> _cb(data);
            } <span class="pl-k">else</span> {
                <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
                <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                    <span class="pl-k">return</span> _data._go(_cb);
                } <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> _cb(_data);
                }
            }
        });
    });
};</pre></div>

<p>Here, let me present the final version of our <code>next</code> function, comparing to <code>_next</code> we write before, can you see what's the different? </p>

<ul>
<li><p>It still reture a new <code>Action</code>, when it fired, the original action are called.</p></li>
<li><p>We checked if the <code>data</code> coming from upstream is <code>instanceof Error</code>, if it's not, everything as usual, we feed it to <code>cb</code> that <code>next</code> received.</p></li>
<li><p>But if it's an <code>Error</code>, we skip <code>cb</code>, pass it to a future <code>_cb</code>, which we don't have now.</p></li>
</ul>

<p><code>next</code> ensure the <code>cb</code> it received, <strong>will never receive an <code>Error</code></strong>, we just skip <code>cb</code> and pass <code>Error</code> downstream, Symmetrically, we define a function which only deal with <code>Error</code>, and let normal values pass:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">guard</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
           <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
                <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                    <span class="pl-k">return</span> _data._go(_cb);
                } <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> _cb(_data);
                }
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> _cb(data);
            }
        });
    });
};</pre></div>

<p>This time, we know the <code>cb</code> that <code>guard</code> received are prepared for <code>Error</code> values, so we flip the logic, you can also return an <code>Action</code> if your need some async code to deal with the <code>Error</code>.</p>

<p>Following code demonstrate how to use our <code>next</code> and <code>guard</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// see how to pass an Error to downstream</span>
            <span class="pl-c">// not reject, not throw, just pass it on, let it go</span>
            cb(err);
        }<span class="pl-k">else</span>{
            cb(data);
        }
    });
})
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// sync process</span>
    <span class="pl-k">return</span> processData(data);
})
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// async process</span>
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        processDataAsync(data, cb);
    })
})
.<span class="pl-c1">next</span>(
    <span class="pl-k">try</span>{
        <span class="pl-k">return</span> someProcessMayWentWrong(data);
    }<span class="pl-k">catch</span>(e){
        <span class="pl-c">// same as above, we return the error to pass it on</span>
        <span class="pl-k">return</span> e;
    }
}))
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// This process will be skip if previous steps pass an Error</span>
    <span class="pl-k">return</span> anotherProcess(data);
})
.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>){
    <span class="pl-c">// This process will be skip if there's no Errors</span>
    <span class="pl-k">return</span> processError(e);
});
._go(<span class="pl-en">console</span>.log);
</pre></div>

<p>The final result will be produced by <code>anotherProcess</code> if <code>someProcessMayWentWrong</code> didn't go wrong and <code>readFile</code> didn't fail, otherwise it will be produced by <code>processError</code>.</p>

<p>You can place <code>guard</code> in the middle of the chain, all <code>Errors</code> before it will be handled by it, and the value it produced, sync or async, will be passed to the rest of the chain.</p>

<p>So, what if we don't supply a <code>guard</code>? Since we have to supply a callback to <code>_go</code>, we can check if the final result is an <code>Error</code> or not like this:</p>

<div class="highlight highlight-source-js"><pre>apiReturnAction(<span class="pl-s"><span class="pl-pds">'</span>...<span class="pl-pds">'</span></span>)._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error){
        <span class="pl-c">//handle error here</span>
        ...
    } <span class="pl-k">else</span> {
        <span class="pl-c">// process data here</span>
        ...
    }
});
</pre></div>

<p>Yeah, it does work(and sometimes you want it work in this way), but:</p>

<ul>
<li><p>we don't want to force our user to supply a <code>cb</code> like above.</p></li>
<li><p>we should throw <code>Error</code> in case user didn't <code>guard</code> them.</p></li>
</ul>

<p>So here let me present the final version of <code>go</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">go</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">return</span> <span class="pl-v">this</span>._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
        <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
            <span class="pl-k">throw</span> data;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (cb <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> cb(data);
        }
    });
};
</pre></div>

<p>Now user can omit the callback, and if user don't guard <code>Error</code>s, we will yell at them when <code>Error</code> occurs!</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// suppose we got an Error here</span>
            cb(err);
        }<span class="pl-k">else</span>{

            cb(data);
        }
    });
})
.<span class="pl-c1">go</span>() <span class="pl-c">// The Error will be thrown!</span>
</pre></div>

<p>Finally, to ease error management, and to attack the <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#2-unsupported-syntax">v8 optimization problems</a>. We recommand using <code>Action.safe</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// this small function minimize v8 try-catch overhead</span>
<span class="pl-c">// and make attaching custom Error easy</span>
<span class="pl-c1">Action</span>.<span class="pl-en">safe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">fn</span>) {
    <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
        <span class="pl-k">try</span> {
            <span class="pl-k">return</span> fn(data);
        } <span class="pl-k">catch</span> (_error) {
            <span class="pl-k">return</span> err;
        }
    };
};</pre></div>

<p>And use <code>safe</code> wrap your <code>someProcessMayWentWrong</code> like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> safe <span class="pl-k">=</span> Action.safe;
<span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            cb(err);
        }<span class="pl-k">else</span>{
            cb(data);
        }
    });
})
.<span class="pl-c1">next</span>(
    safe( <span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">"</span>PROCESS_ERROR_XXX: process xxx failed when xxx<span class="pl-pds">"</span></span>)
        , someProcessMayWentWrong)
)
.<span class="pl-c1">next</span>(...)
.<span class="pl-c1">next</span>(...)
.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>){
    <span class="pl-k">if</span> (e.message.<span class="pl-c1">indexOf</span>(<span class="pl-s"><span class="pl-pds">'</span>ENOENT<span class="pl-pds">'</span></span>) <span class="pl-k">===</span> <span class="pl-c1">0</span>){
        ...
    }
    <span class="pl-k">if</span> (e.message.<span class="pl-c1">indexOf</span>(<span class="pl-s"><span class="pl-pds">'</span>PROCESS_ERROR_XXX<span class="pl-pds">'</span></span>) <span class="pl-k">===</span> <span class="pl-c1">0</span> ){
        ...
    }
})
.<span class="pl-c1">go</span>()
</pre></div>

<p>That's all core functions of <code>Action</code> is going to give you, thank you for reading, how long does it take you? hope you enjoy my solution :)</p>

<ul>
<li><p>Check <a href="https://github.com/winterland1989/Action.js/wiki/API-document">API doc</a> for interesting things like <code>Action.parallel</code>, <code>Action.race</code>, <code>Action.sequence</code> and <code>Action.retry</code>.</p></li>
<li><p>Read <a href="https://github.com/winterland1989/Action.js/wiki/Return-value-of-go">Return value of go</a> to learn how to cancel an <code>Action</code>.</p></li>
<li><p>Read <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to get a deeper understanding.</p></li>
</ul>

<h1>
<a id="faq" class="anchor" href="#faq" aria-hidden="true"><span class="octicon octicon-link"></span></a>FAQ<a name="FAQ"></a>
</h1>

<h2>
<a id="what-makes-action-fast" class="anchor" href="#what-makes-action-fast" aria-hidden="true"><span class="octicon octicon-link"></span></a>What makes <code>Action</code> fast?</h2>

<p>Check out <a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">Benchmark</a>, even use bluebird's benchmark suit, which heavily depend on library's <a href="https://github.com/petkaantonov/bluebird/blob/master/src/promisify.js#L124">promisify</a> implementation, <code>Action</code> can match bluebird's performance.</p>

<p>Generally speaking, <code>Action</code> simply does less work:</p>

<ul>
<li><p>It doesn't maintain any internal state.</p></li>
<li><p>It just have a single field, which is a reference to a function.</p></li>
<li><p>It just add a redirect call to original callback, and some type checking.</p></li>
</ul>

<h2>
<a id="why-following-code-doesnt-work" class="anchor" href="#why-following-code-doesnt-work" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why following code doesn't work?</h2>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> fileA <span class="pl-k">=</span> readFileAction
.<span class="pl-c1">go</span>(processOne)

<span class="pl-c">// Error, fileA is not an Action anymore</span>
fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()</pre></div>

<p>Well, read <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to get a detailed answer, tl,dr... here is the short answer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// readFile now and return a Action, this function won't block</span>
<span class="pl-k">var</span> fileA <span class="pl-k">=</span> Action.freeze(readFileAction.<span class="pl-c1">next</span>(processOne))

<span class="pl-c">// now fileA will always have the same content</span>
<span class="pl-c">// and file will never be read again.</span>
fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()

<span class="pl-c">// processTwo will receive the same content</span>
fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()</pre></div>

<p>If you want have a <code>Promise</code> behavior(fire and memorize), use <code>Action.freeze</code>, <code>go</code> won't return a new <code>Action</code>.</p>

<h2>
<a id="when-to-use-this-library" class="anchor" href="#when-to-use-this-library" aria-hidden="true"><span class="octicon octicon-link"></span></a>When to use this library?</h2>

<p>With <code>Promise</code> added to ES6 and ES7 <code>async/await</code> proposal, one must ask, why another library to do the same things again?</p>

<p>Actually <code>Action</code> have a <a href="https://github.com/winterland1989/Action.js/blob/master/Action.coffee#L205">very elegant <code>Action.co</code> implementation</a> to work with generators, nevertheless, use this library if you:</p>

<ul>
<li><p>Want something small, fast and memory effient in browser, Action.js even have <code>ajax/jsonp</code> bundled.</p></li>
<li><p>Want manage cancelable actions, read the <a href="https://github.com/winterland1989/Action.js/wiki/Return-value-of-go">Return value of go</a> to get a elegant solution to cancelable actions.</p></li>
<li><p>Want a different sementics, with <code>Promise</code>, you just can't reuse your callback chain, you have to create a new <code>Promise</code>, with <code>Action</code>, just <code>go</code> again, never waste memory on GC. </p></li>
<li><p>Want to control exactly when the action will run, with <code>Promise</code>, all action run in next tick, While with <code>Action</code>, action runs when you call <code>go</code>, <code>_go</code> or <code>Action.freeze</code>. </p></li>
<li><p>Want raw speed, this is somehow not really an issue, most of the time, <code>Promise</code> or <code>Action</code> won't affect that much, and on node we have heavily v8-optimized bluebird, nevertheless, <code>Action.js</code> can guarantee speed close to handroll callbacks in any runtime, just much cleaner.</p></li>
</ul>

<p>If you have a FP background, you must find all i have done is porting the <code>Cont</code> monad from Haskell, and i believe you have divided your program into many composable functions already, just connect them with <code>next</code>.</p>

<h2>
<a id="how-can-i-send-an-error-to-downstreams-next" class="anchor" href="#how-can-i-send-an-error-to-downstreams-next" aria-hidden="true"><span class="octicon octicon-link"></span></a>How can i send an <code>Error</code> to downstream's <code>next</code>
</h2>

<p>No, you can't, however, you can receive <code>Error</code> from upstream use <code>_next</code>, <code>_go</code> or <code>guard</code>. or you can wrap the <code>Error</code> in an <code>Array</code> like <code>[e]</code>.</p>

<p>The choice of using <code>Error</code> to skip <code>next</code> and hit <code>guard</code> is not arbitrary, instead of creating an <code>ActionError</code> class, use <code>Error</code> unify type with system runtime, and providing callstack information. And you can now break your program by throwing an Error if you really want to.</p>

<h1>
<a id="changelog" class="anchor" href="#changelog" aria-hidden="true"><span class="octicon octicon-link"></span></a>Changelog<a name="Changelog"></a>
</h1>

<p>v2.0.0
Update doc, Remove <code>gapRetry</code>, since it's just a <code>retry</code> compose <code>delay</code>. </p>

<p>v1.4.1
Run bluebird benchmark, add some optimization.</p>

<p>v1.4.0
Add Action.co, fix Action.join typos, test cover 100% agian.</p>

<p>v1.3.0
Add Action.join, optimized internal</p>

<p>v1.2.4
Improve makeNodeAction</p>

<p>v1.2.3
Fix responseType related.</p>

<p>v1.2.2
Auto add header based on data type.</p>

<p>v1.2.1
Clear some error types.</p>

<p>v1.2.0
add <code>param</code>, <code>jsonp</code> and <code>ajax</code> for front-end usage.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/winterland1989">winterland1989</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
