<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Action.js by winterland1989</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Action.js</h1>
        <p>A sane way to write async code</p>

        <p class="view"><a href="https://github.com/winterland1989/Action.js">View the Project on GitHub <small>winterland1989/Action.js</small></a></p>


        <ul>
          <li><a href="https://github.com/winterland1989/Action.js/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/winterland1989/Action.js/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/winterland1989/Action.js">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="actionjs-a-sane-way-to-write-async-code" class="anchor" href="#actionjs-a-sane-way-to-write-async-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Action.js, a sane way to write async code</h1>

<ul>
<li><a href="#FAQ">FAQ</a></li>
<li><a href="https://github.com/winterland1989/Action.js/wiki/API-document">API document</a></li>
<li>Usage: <code>npm i action-js</code> or <code>git clone https://github.com/winterland1989/Action.js.git</code>
</li>
</ul>

<p>Action.js offer a <a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">faster</a> and simpler(~200LOC, 7.7kB w/o minified, ~1kB minified gzippe) alternative to <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Promise</a>, got 5 minutes?</p>

<h2>
<a id="understand-actionjs-in-5-minutes" class="anchor" href="#understand-actionjs-in-5-minutes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Understand Action.js in 5 minutes</h2>

<p>Suppose we want to solve the nest callback problem form scratch, there's an async function called <code>readFile</code>, and we want to use it to read <code>data.txt</code>, we have to supply a <code>callback</code> to it:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// suppose this simple readFile never fail</span>
readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
});</pre></div>

<p>Instead we don't give a callback(the <code>console.log</code>) to it right now, we save this read action in a new <code>Action</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">Action</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">Action</span>(<span class="pl-smi">action1</span>) {
    <span class="pl-v">this</span>._go <span class="pl-k">=</span> action1;
}

<span class="pl-k">var</span> readFileAction <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(
    <span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, cb);
    }
);</pre></div>

<p>We have following objects on our heap:</p>

<pre><code>+----------------+-------+
| readFileAction | ._go  | 
+----------------+----+--+
                      |
                      v
                +----------+---------------+
                | function | cb            |
                +----------+---------------+   
                | readFile("data.txt", cb) |
                +--------------------------+
</code></pre>

<p>Ok, now we must have a way to extract the action from our <code>readFileAction</code>, let's using <code>readFileAction._go</code> directly:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// actually you can just write readFileAction._go(console.log)</span>
readFileAction._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
})</pre></div>

<p>What above does is equivalent to what we write at beginning, right?:</p>

<div class="highlight highlight-source-js"><pre>readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
});</pre></div>

<p>Just with one difference, we seperate action creation(wrap <code>readFile</code> in <code>new Action</code>) and application(supply a callback to <code>_go</code>), Now we want to chain more callbacks in Promise <code>then</code> style:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
            <span class="pl-k">return</span> _cb(_data);
        });
    });
};</pre></div>

<p>Let's break down <code>_next</code> a little here:</p>

<ul>
<li><p><code>_next</code> accept a callback <code>cb</code>, and return a new <code>Action</code>.</p></li>
<li><p>When the new <code>Action</code> fired with <code>_cb</code>, the original <code>Action</code>'s action will be fired first, and send the value to <code>cb</code>.</p></li>
<li><p>We apply <code>cb</code> with <code>data</code> from the original <code>Action</code></p></li>
<li><p>Then we send the <code>_data</code> produced by <code>cb(data)</code> to <code>_cb</code>.</p></li>
<li><p>The order is (original <code>Action</code>'s <code>_go</code>) --&gt; (<code>cb</code> which <code>next</code> received) --&gt; (<code>_cb</code> we give to our new <code>Action</code>).</p></li>
<li><p>Since we haven't fired our new <code>Action</code> yet, we haven't send the <code>_cb</code>, the whole callback chain is saved in our new <code>Action</code>.</p></li>
</ul>

<p>With our <code>_next</code>, we can chain multiply callbacks and pass data between them:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> data.<span class="pl-c1">length</span>;
})
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is the length we obtain last step</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
    <span class="pl-k">return</span> length <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
})
._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is a Boolean</span>
    <span class="pl-k">if</span>(data){
        ...
    }
})</pre></div>

<p>Let's present it in a diagram:</p>

<pre><code>+----------------+-------+
| ActionTwo      | ._go  | 
+----------------+----+--+
                      |
                      v
                +----------+----------------+
                | function | cb_            |
                +----------+----------------+  
                | cb = function(data){      |
                |   console.log(data);      |
                |   return length &gt; 0       |
                | }                         |
           +--- + ActionOne._go(            |
           |    |   function(data){         |
           |    |     cb_(cb(data))         |
           |    |   });                     | 
           |    +---------------------------+
           |                            
           v       
+----------------+-------+            
| ActionOne      | ._go  | 
+----------------+----+--+
                      |
                      v
                +----------+----------------+
                | function | cb_            |
                +----------+----------------+  
                | cb = function(data){      |
                |   return data.length      |
                | }                         |
           +--- + readFileAction._go(       |
           |    |   function(data){         |
           |    |     cb_(cb(data))         |
           |    |   });                     | 
           |    +---------------------------+
           |           
           v          
+----------------+-------+
| readFileAction | ._go  | 
+----------------+----+--+
                      |
                      v
                +----------+---------------+
                | function | cb            |
                +----------+---------------+   
                | readFile("data.txt", cb) |
                +--------------------------+
</code></pre>

<p><code>ActionOne</code> and <code>ActionTwo</code> are <code>Action</code>s first and second <code>_next</code> returned respectively, Now if we give <code>ActionTwo</code> a callback with <code>_go</code>, the whole callback chain will be fired sequential.</p>

<p>Nice, we just use a simple class with only one field, two very simple functions, the callbacks are now written in a much more readable way, but we have a key problem to be solved yet: what if we want to nest async <code>Action</code>s inside an <code>Action</code>? Turn out with a little modification to our <code>_next</code> function, we can handle that:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
            <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                <span class="pl-k">return</span> _data._go(_cb);
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> _cb(_data);
            }
        });
    });
};</pre></div>

<p>We use <code>instanceof Action</code> to check if a callback returns an <code>Action</code> or not, if an <code>Action</code> is returned, we fire it with <code>_cb</code>, the callback which our new <code>Action</code> will going to receive:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">var</span> newFile <span class="pl-k">=</span> <span class="pl-c1">parse</span>(data);
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        readFile(newFile, cb);
    });
})
._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is the newFile's content</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data)
})</pre></div>

<p>Now we can say we have solved the callback hell problem! Well, actually just 50% of it.
Before we proceed another 50%, one important thing to keep in mind: <strong>an <code>Action</code> is not a <code>Promise</code>, it will not happen if you don't fire it with <code>_go</code>, and it can be fired multiple times, it's just a reference to a wrapped function</strong>:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(processOne)
._go(<span class="pl-en">console</span>.log)

<span class="pl-c">// after we do other things, or inside another request handler</span>
...

<span class="pl-c">// processTwo may receive different data since the file may change!</span>
readFileAction
._next(processTwo)
._go(<span class="pl-en">console</span>.log)</pre></div>

<p>I'll present <code>Action.freeze</code> in <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to give you Promise behavior when you need it, now let's attack another 50% of the callback hell issue.</p>

<h2>
<a id="error-handling" class="anchor" href="#error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error handling</h2>

<p>One biggest issue with <code>Promise</code> is that error handleing is somewhat magic and complex:</p>

<ul>
<li><p>It will eat your error sliently if you don't supply a <code>catch</code> at the end of the chain.</p></li>
<li><p>You have to use two different functions, <code>resolve</code> to pass value to the callbacks and <code>reject</code> to skip them, what will happen if you <code>throw</code> an <code>Error</code>, well, just the same as <code>reject</code>.</p></li>
</ul>

<p>What we can do to make it simpler? It's a complex problem, we start solving it by simplify it: <strong>Action.js use <code>Error</code> type as a special type to pass error information to the downstream</strong>, what does this mean?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
                <span class="pl-k">return</span> _cb(data);
            } <span class="pl-k">else</span> {
                <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
                <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                    <span class="pl-k">return</span> _data._go(_cb);
                } <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> _cb(_data);
                }
            }
        });
    });
};</pre></div>

<p>Here, let me present the final version of our <code>next</code> function, comparing to <code>_next</code> we write before, can you see what's the different? </p>

<ul>
<li><p>It still reture a new <code>Action</code>, when it fired, the original action are called.</p></li>
<li><p>We checked if the data are <code>instanceof Error</code>, if it's not, everything as usual, we feed it to <code>cb</code> that <code>next</code> received.</p></li>
<li><p>But if it's an <code>Error</code>, we pass it to a future <code>_cb</code>, which we don't have now.</p></li>
</ul>

<p><code>next</code> ensure the <code>cb</code> it received, <strong>will never receive an <code>Error</code></strong>, we just skip <code>cb</code> and pass <code>Error</code> downstream, Symmetrically, we define a function which only deal with <code>Error</code>, and let normal values pass:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">guard</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> _go <span class="pl-k">=</span> <span class="pl-v">this</span>._go;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> _go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
           <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
                <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                    <span class="pl-k">return</span> _data._go(_cb);
                } <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> _cb(_data);
                }
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> _cb(data);
            }
        });
    });
};</pre></div>

<p>This time, we know the <code>cb</code> that <code>guard</code> received are prepared for <code>Error</code> values, so we flip the logic, you can also return an <code>Action</code> if your need some async code to deal with the <code>Error</code>.</p>

<p>Following code demonstrate how to use our <code>next</code> and <code>guard</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// see how to pass an Error to downstream</span>
            <span class="pl-c">// not reject, not throw, just pass it on, let it go</span>
            cb(err);
        }<span class="pl-k">else</span>{

            cb(data);
        }
    });
})
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> processData(data);
})
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        processDataAsync(data, cb);
    })
})
.<span class="pl-c1">next</span>(
    <span class="pl-k">try</span>{
        <span class="pl-k">return</span> someProcessMayWentWrong(data);
    }<span class="pl-k">catch</span>(e){
        <span class="pl-c">// same as above, we return the error to pass it on</span>
        <span class="pl-k">return</span> e;
    }
}))
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// This process will be skip if previous steps pass an Error</span>
    <span class="pl-k">return</span> anotherProcess(data);
})
.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>){
    <span class="pl-c">// This process will be skip if there's no Errors</span>
    <span class="pl-k">return</span> processError(e);
});
._go(<span class="pl-en">console</span>.log);
</pre></div>

<p>The final result will be produced by <code>anotherProcess</code> if <code>someProcessMayWentWrong</code> didn't go wrong or <code>readFile</code> failed, otherwise it will be produced by <code>processError</code>.</p>

<p>You can place <code>guard</code> in the middle of the chain, all <code>Errors</code> before it will be handled by it, and the value it produced, sync or async, will be passed to the rest of the chain.</p>

<p>So, what if we don't supply a <code>guard</code>? Since we have to supply a callback to the <code>_go</code>, we can check if the callback we supplied received an <code>Error</code> or not like this:</p>

<div class="highlight highlight-source-js"><pre>apiReturnAction(<span class="pl-s"><span class="pl-pds">'</span>...<span class="pl-pds">'</span></span>)._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error){
        <span class="pl-c">//handle error here</span>
        ...
    } <span class="pl-k">else</span> {
        <span class="pl-c">// process data here</span>
        ...
    }
});
</pre></div>

<p>Yeah, it does work(and sometimes you want it work in this way), but:</p>

<ul>
<li><p>we don't want to force our user to supply a <code>cb</code> like above.</p></li>
<li><p>we should throw <code>Error</code> in case user didn't <code>guard</code> them.</p></li>
</ul>

<p>So here let me present the final version of <code>go</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">go</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">return</span> <span class="pl-v">this</span>._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
        <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
            <span class="pl-k">throw</span> data;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (cb <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> cb(data);
        }
    });
};
</pre></div>

<p>Now user can omit the callback, and if user don't guard <code>Error</code>s, we will yell at them when <code>Error</code> occurs!</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// suppose we got an Error here</span>
            cb(err);
        }<span class="pl-k">else</span>{

            cb(data);
        }
    });
})
.<span class="pl-c1">go</span>() <span class="pl-c">// The Error will be thrown!</span>
</pre></div>

<p>Finally, to ease error management, and to attack the <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#2-unsupported-syntax">v8 optimization problems</a>. We recommand using <code>Action.safe</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// this small function minimize v8 try-catch overhead</span>
<span class="pl-c">// and make attaching custom Error easy</span>
<span class="pl-c1">Action</span>.<span class="pl-en">safe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">fn</span>) {
    <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
        <span class="pl-k">try</span> {
            <span class="pl-k">return</span> fn(data);
        } <span class="pl-k">catch</span> (_error) {
            <span class="pl-k">return</span> err;
        }
    };
};</pre></div>

<p>And use <code>safe</code> wrap your <code>someProcessMayWentWrong</code> like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> safe <span class="pl-k">=</span> Action.safe;
<span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// see how to pass an Error to downstream, not reject, not throw, just return</span>
            cb(err);
        }<span class="pl-k">else</span>{
            cb(data);
        }
    });
})
.<span class="pl-c1">next</span>(
    safe( <span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">"</span>PROCESS_ERROR_XXX: process xxx failed when xxx<span class="pl-pds">"</span></span>)
        , someProcessMayWentWrong)
)
.<span class="pl-c1">next</span>(...)
.<span class="pl-c1">next</span>(...)
.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>){
    <span class="pl-k">if</span> (e.message.<span class="pl-c1">indexOf</span>(<span class="pl-s"><span class="pl-pds">'</span>ENOENT<span class="pl-pds">'</span></span>) <span class="pl-k">===</span> <span class="pl-c1">0</span>){
        ...
    }
    <span class="pl-k">if</span> (e.message.<span class="pl-c1">indexOf</span>(<span class="pl-s"><span class="pl-pds">'</span>PROCESS_ERROR_XXX<span class="pl-pds">'</span></span>) <span class="pl-k">===</span> <span class="pl-c1">0</span> ){
        ...
    }
})
.<span class="pl-c1">go</span>()
</pre></div>

<p>That's all core functions of <code>Action</code> is going to give you, thank you for reading, how long does it take you? hope you enjoy my solution :)</p>

<ul>
<li><p>Check <a href="https://github.com/winterland1989/Action.js/wiki/API-document">API doc</a> for interesting things like <code>Action.parallel</code>, <code>Action.race</code>, <code>Action.sequence</code> and <code>Action.retry</code>.</p></li>
<li><p>Read <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to get a deeper understanding.</p></li>
</ul>

<h1>
<a id="faq" class="anchor" href="#faq" aria-hidden="true"><span class="octicon octicon-link"></span></a>FAQ<a name="FAQ"></a>
</h1>

<h2>
<a id="what-makes-action-faster-than-promise" class="anchor" href="#what-makes-action-faster-than-promise" aria-hidden="true"><span class="octicon octicon-link"></span></a>What makes <code>Action</code> faster than <code>Promise</code>?</h2>

<p>Because it simply does less work:</p>

<ul>
<li><p>It doesn't maintain any internal state.</p></li>
<li><p>It just have a single field, which is a reference to a function.</p></li>
<li><p>It just add a redirect call to original callback, and some type checking.</p></li>
</ul>

<p>I even be amazed it can achieve so much functionality with such short code myself, see <a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">Benchmark</a> youself.</p>

<h2>
<a id="why-following-code-doesnt-work" class="anchor" href="#why-following-code-doesnt-work" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why following code doesn't work?</h2>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> fileA <span class="pl-k">=</span> readFileAction
.<span class="pl-c1">go</span>(processOne)

fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()</pre></div>

<p>Well, read <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to get a detailed answer, tl,dr... here is the short answer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// readFile now and return a Action, this function won't block</span>
<span class="pl-k">var</span> fileA <span class="pl-k">=</span> Action.freeze(readFileAction.<span class="pl-c1">next</span>(processOne))

<span class="pl-c">// now fileA will always have the same content and file will never be read again.</span>
fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()

<span class="pl-c">// processTwo will receive the same content</span>
fileA
.<span class="pl-c1">next</span>(processTwo)
.<span class="pl-c1">go</span>()</pre></div>

<p>If you want have a Promise behavior(fire and memorize), use <code>Action.freeze</code>, <code>go</code> won't return a new <code>Action</code>.</p>

<h2>
<a id="when-to-use-this-library" class="anchor" href="#when-to-use-this-library" aria-hidden="true"><span class="octicon octicon-link"></span></a>When to use this library?</h2>

<p>With <code>Promise</code> added to ES6 and ES7 <code>async/await</code> proposal, one must ask, why another library to do the same things again?</p>

<p>I actually can add generator support with something like <code>Action.async</code> when ES6 come to most browser, but i can see future will be full of <code>async</code> functions all over the place, use this library if you:</p>

<ul>
<li><p>Have a FP background, you must find all i have done is porting the <code>Cont</code> monad from Haskell, and i believe you have divided your program into many composable functions already, just connect them with <code>next</code>.</p></li>
<li><p>Want something small and memory effient in browser.</p></li>
<li><p>Want to control exactly when the action will run, with <code>Promise</code>, all action run in next tick, While with <code>Action</code>, action runs when you call <code>go</code>, <code>_go</code> or <code>Action.freeze</code>. </p></li>
<li><p>Want a different sementics, with <code>Promise</code>, you just can't reuse your callback chain, we have to create a new <code>Promise</code>, with <code>Action</code>, just <code>go</code> again, never waste memory on GC. </p></li>
</ul>

<p>Consider following code, and try to rewrite it with <code>Promise</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-en">retry</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">times</span>, <span class="pl-smi">action</span>) {
    <span class="pl-k">var</span> a;
    <span class="pl-k">return</span> a <span class="pl-k">=</span> action.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>) {
        <span class="pl-k">if</span> (times<span class="pl-k">--</span> <span class="pl-k">!==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> a;
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">'</span>RETRY_ERROR: Retry limit reached<span class="pl-pds">'</span></span>);
        }
    });
};</pre></div>

<ul>
<li>Want raw speed, this is somehow not really an issue, most of the time, <code>Promise</code> or <code>Action</code> won't affect that much, nevertheless, <code>Action.js</code> can guarantee speed close to handroll callbacks, just much cleaner.</li>
</ul>

<h2>
<a id="how-can-i-send-an-error-to-downstreams-next" class="anchor" href="#how-can-i-send-an-error-to-downstreams-next" aria-hidden="true"><span class="octicon octicon-link"></span></a>How can i send an <code>Error</code> to downstream's <code>next</code>
</h2>

<p>No, you can't, you have to wrap it in a <code>Array</code> or <code>Object</code> or <code>Map</code>...whatever, the choice of using <code>Error</code> to skip <code>next</code> and hit <code>guard</code> is not arbitrary, instead of creating an <code>ActionError</code> class, use <code>Error</code> unify type with system runtime, and providing callstack information.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/winterland1989">winterland1989</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
