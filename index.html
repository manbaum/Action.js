<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Action.js by winterland1989</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Action.js</h1>
      <h2 class="project-tagline">A clean alternative to promise</h2>
      <a href="https://github.com/winterland1989/Action.js" class="btn">View on GitHub</a>
      <a href="https://github.com/winterland1989/Action.js/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/winterland1989/Action.js/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="actionjs-a-sane-way-to-write-async-code" class="anchor" href="#actionjs-a-sane-way-to-write-async-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Action.js, a sane way to write async code</h1>

<p>Action.js offer a <a href="https://github.com/winterland1989/Action.js/wiki/Benchmark">faster</a> and simpler(~200LOC) alternative to <a href="http://promisesaplus.com">Promise</a>, got 5 minutes?</p>

<h2>
<a id="understand-actionjs-in-5-minutes" class="anchor" href="#understand-actionjs-in-5-minutes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Understand Action.js in 5 minutes</h2>

<p>Suppose we want to solve the nest callback problem form scratch, there's an async function called <code>readFile</code>, and we want to use it to read <code>data.txt</code>, we have to supply a <code>callback</code> to it:</p>

<pre><code>readFile("data.txt", callback)
</code></pre>

<p>Instead we don't give a callback to it right now, we save this read action in a new <code>Action</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">Action</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">Action</span>(<span class="pl-smi">action1</span>) {
    <span class="pl-v">this</span>.<span class="pl-c1">action</span> <span class="pl-k">=</span> action1;
}

<span class="pl-k">var</span> readFileAction <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(
    <span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, cb);
    }
);</pre></div>

<p>We have following objects on our heap:</p>

<pre><code>+----------------+----------+
| readFileAction | .action  | 
+----------------+----+-----+
                      |
                      v
                +----------+---------------+
                | function | cb            |
                +----------+---------------+   
                | readFile("data.txt", cb) |
                +--------------------------+
</code></pre>

<p>Ok, now we must have a way to extract the action from our <code>readFileAction</code>, instead of using <code>readFileAction.action</code> directly, we write a function to accpet a callback, and pass this callback to the action inside our <code>readFileAction</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_go</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">action</span>(cb);
};
readFileAction._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
})</pre></div>

<p>You should understand what above <code>_go</code> does is equivalent to following:</p>

<div class="highlight highlight-source-js"><pre>readFile(<span class="pl-s"><span class="pl-pds">"</span>data.txt<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
});</pre></div>

<p>Just with one difference, we seperate action creation(wrap <code>readFile</code> in <code>new Action</code>) and application(use <code>_go</code> to supply a callback), in fact we have successfully did a <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">CPS transformation</a>, we will talk about that later.</p>

<p>Now we want to chain more callbacks in Promise <code>then</code> style:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> self.<span class="pl-c1">action</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
            <span class="pl-k">return</span> _cb(_data);
        });
    });
};</pre></div>

<p>Let's break down <code>_next</code> a little here:</p>

<ul>
<li><p><code>_next</code> accept a callback <code>cb</code>, and return a new <code>Action</code>.</p></li>
<li><p>When the new <code>Action</code> fired, the original <code>Action</code>'s action will be fired first, and send the value to <code>cb</code>.</p></li>
<li><p>we save the <code>_data</code> produced by <code>cb</code>, and wait for a future <code>_cb</code>.</p></li>
</ul>

<p>With our <code>_next</code>, we can chain multiply callbacks and pass data between them:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> data.<span class="pl-c1">length</span>;
})
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is the length we obtain last step</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data);
    <span class="pl-k">return</span> length <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
})
._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is a Boolean</span>
    <span class="pl-k">if</span>(data){
        ...
    }
})</pre></div>

<p>If we want to present it with diagram, it should look like this:</p>

<pre><code>+----------------+----------+
| ActionTwo      | .action  | 
+----------------+----+-----+
                      |
                      v
                +----------+----------------+
                | function | cb_            |
                +----------+----------------+  
                | cb = function(data){      |
                |   console.log(data);      |
                |   return length &gt; 0       |
                | }                         |
           +--- + ActionOne.action(         |
           |    |   function(data){         |
           |    |     cb_(cb(data))         |
           |    |   });                     | 
           |    +---------------------------+
           |                            
           v       
+----------------+----------+            
| ActionOne      | .action  | 
+----------------+----+-----+
                      |
                      v
                +----------+----------------+
                | function | cb_            |
                +----------+----------------+  
                | cb = function(data){      |
                |   return data.length      |
                | }                         |
           +--- + readFileAction.action(    |
           |    |   function(data){         |
           |    |     cb_(cb(data))         |
           |    |   });                     | 
           |    +---------------------------+
           |           
           v          
+----------------+----------+
| readFileAction | .action  | 
+----------------+----+-----+
                      |
                      v
                +----------+---------------+
                | function | cb            |
                +----------+---------------+   
                | readFile("data.txt", cb) |
                +--------------------------+
</code></pre>

<p><code>ActionOne</code> and <code>ActionTwo</code> are <code>Action</code>s first and second <code>_next</code> returned respectively, Now if we give <code>ActionTwo</code> a <code>callback</code> with <code>_go</code>, the whole callback chain will be fired sequential.</p>

<p>Nice, we just use a simple class with only one field, two very simple functions, the callbacks are now written in a much more readable way, but we have a key problem to be solved yet: what if we want to nest async <code>Action</code>s inside an <code>Action</code>, it turn out with an adjusted <code>_next</code> function, we can handle that:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">_next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> self.<span class="pl-c1">action</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
            <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                <span class="pl-k">return</span> _data._go(_cb);
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> _cb(_data);
            }
        });
    });
};</pre></div>

<p>We use <code>instanceof Action</code> to check if a callback returns a <code>Action</code> or not, if an <code>Action</code> is returned, we fire it with callbacks in future:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">var</span> newFile <span class="pl-k">=</span> <span class="pl-c1">parse</span>(data);
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        readFile(newFile, cb);
    });
})
._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// data here is the newFile's content</span>
    <span class="pl-en">console</span>.<span class="pl-c1">log</span>(data)
})</pre></div>

<p>Now we can say we have solved the callback hell problem! Well, actually just 50% of it.
Before we proceed another 50%, one important thing to keep in mind: <strong>an <code>Action</code> is not a <code>Promise</code>, it will not happen if you don't fire it with <code>_go</code>, and it can be fired multiple times, it's just a reference to a wrapped function</strong>:</p>

<div class="highlight highlight-source-js"><pre>readFileAction
._next(processOne)
._go(<span class="pl-en">console</span>.log)

<span class="pl-c">// after we do other things, or inside another request handler</span>
...

<span class="pl-c">// processTwo may receive different data since the file may change!</span>
readFileAction
._next(processTwo)
._go(<span class="pl-en">console</span>.log)</pre></div>

<p>I'll present <code>Action.freeze</code> in <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to give you Promise behavior when you need it, now let's attack another 50% of the callback hell issue.</p>

<h2>
<a id="error-handling" class="anchor" href="#error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error handling</h2>

<p>One biggest issue with <code>Promise</code> is that error handleing is somewhat magic and complex:</p>

<ul>
<li><p>It will eat your error sliently if you don't supply a <code>catch</code> at the end of the chain.</p></li>
<li><p>You have to use two different functions, <code>resolve</code> to pass value to the callbacks and <code>reject</code> to skip them, what will happen if you <code>throw</code> an <code>Error</code>, well, just the same as <code>reject</code></p></li>
</ul>

<p>What we can do to make it simpler? It's a complex problem, so we start solving it by simplify it: <strong>We use <code>Error</code> type as a special type to pass error information to the downstream</strong>, what does this mean?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">next</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> self.<span class="pl-c1">action</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
            <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
                <span class="pl-k">return</span> _cb(data);
            } <span class="pl-k">else</span> {
                <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
                <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                    <span class="pl-k">return</span> _data._go(_cb);
                } <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> _cb(_data);
                }
            }
        });
    });
};</pre></div>

<p>Here, let me present the final version of our <code>next</code> function, comparing to <code>_next</code> we write before, can you see what's the different? It still reture a new <code>Action</code>, when it fired, the original action are called, and we checked if the data are <code>instanceof Error</code>, if it's not, everything as usual, we feed it to <code>cb</code> that <code>next</code> received, but if it's an <code>Error</code>, we pass it to a future <code>_cb</code>, which we don't have now.</p>

<p>Symmetrically, we have to define a function that special deal with <code>Errors</code>, and let normal values pass:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">guard</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">_cb</span>) {
        <span class="pl-k">return</span> self.<span class="pl-c1">action</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
           <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
            <span class="pl-k">var</span> _data <span class="pl-k">=</span> cb(data);
                <span class="pl-k">if</span> (_data <span class="pl-k">instanceof</span> Action) {
                    <span class="pl-k">return</span> _data._go(_cb);
                } <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> _cb(_data);
                }
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> _cb(data);
            }
        });
    });
};</pre></div>

<p>This time, we know the <code>cb</code> that <code>guard</code> received are prepared for <code>Error</code> values, so we flip the logic.</p>

<p>Following code demonstrate how to use our <code>next</code> and <code>guard</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// see how to pass an Error to downstream, not reject, not throw, just return</span>
            cb(err);
        }<span class="pl-k">else</span>{

            cb(data);
        }
    });
})
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> processData(data);
})
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
        processDataAsync(data, cb);
    })
})
.<span class="pl-c1">next</span>(
    <span class="pl-k">try</span>{
        <span class="pl-k">return</span> someProcessMayWentWrong(data);
    }<span class="pl-k">catch</span>(e){
        <span class="pl-c">// same as above, we return the error</span>
        <span class="pl-k">return</span> e;
    }
}))
.<span class="pl-c1">next</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// This process will be skip if previous step pass an Error</span>
    <span class="pl-k">return</span> anotherProcess(data);
})
.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>){
    <span class="pl-c">// This process will be skip if there's no Errors</span>
    <span class="pl-k">return</span> processError(e);
});
._go(<span class="pl-en">console</span>.log);
</pre></div>

<p>The final result will be produced by <code>anotherProcess</code> if <code>someProcessMayWentWrong</code> didn't go wrong, or produced by <code>processError</code> otherwise.</p>

<p>You can place <code>guard</code> in the middle of the chain, all <code>Errors</code> before if will be handled by it, and the value it produced, will be passed to the rest of the chain.</p>

<p>So, what if the use didn't supply a <code>guard</code>? Well, since use have to supply a callback to the <code>_go</code>, they can check if the callback they supplied received an <code>Error</code> or not like this:</p>

<div class="highlight highlight-source-js"><pre>apiReturnAction(<span class="pl-s"><span class="pl-pds">'</span>...<span class="pl-pds">'</span></span>)._go(<span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error){
        <span class="pl-c">//handle error here</span>
        ...
    } <span class="pl-k">else</span> {
        <span class="pl-c">// process data here</span>
        ...
    }
});
</pre></div>

<p>Yeah, it does work, but we don't want force our user to write like above, and we should throw <code>Error</code> in case user didn't <code>guard</code> them:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Action</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">go</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">action</span>(<span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
        <span class="pl-k">if</span> (data <span class="pl-k">instanceof</span> Error) {
            <span class="pl-k">throw</span> data;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (cb <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> cb(data);
        }
    });
};
</pre></div>

<p>Now if user don't guard <code>Error</code>s, we will yell at them when <code>Error</code> occurs!</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// suppose we got an Error here</span>
            cb(err);
        }<span class="pl-k">else</span>{

            cb(data);
        }
    });
})
.<span class="pl-c1">go</span>() <span class="pl-c">// The Error will be throw!</span>
</pre></div>

<p>Finally, to ease error management, and to attack the <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#2-unsupported-syntax">v8 optimization problems</a>. We recommand use <code>Action.safe</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// this small function minimize v8 try-catch overhead</span>
<span class="pl-c">// and make attaching custom Error easy</span>
<span class="pl-c1">Action</span>.<span class="pl-en">safe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">fn</span>) {
    <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
        <span class="pl-k">try</span> {
            <span class="pl-k">return</span> fn(data);
        } <span class="pl-k">catch</span> (_error) {
            <span class="pl-k">return</span> _error;
        }
    };
};</pre></div>

<p>And use <code>safe</code> wrap your <code>someProcessMayWentWrong</code> like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> safe <span class="pl-k">=</span> Action.safe;
<span class="pl-k">new</span> <span class="pl-en">Action</span>(<span class="pl-k">function</span>(<span class="pl-smi">cb</span>){
    readFile(<span class="pl-s"><span class="pl-pds">'</span>fileA<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>, <span class="pl-smi">data</span>){
        <span class="pl-k">if</span> (err){
            <span class="pl-c">// see how to pass an Error to downstream, not reject, not throw, just return</span>
            cb(err);
        }<span class="pl-k">else</span>{
            cb(data);
        }
    });
})
.<span class="pl-c1">next</span>(
    safe(<span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">"</span>PROCESS_ERROR_XXX: process xxx failed when xxx<span class="pl-pds">"</span></span>), someProcessMayWentWrong)
)
.<span class="pl-c1">next</span>(...)
.<span class="pl-c1">next</span>(...)
.guard(<span class="pl-k">function</span>(<span class="pl-smi">e</span>){
    <span class="pl-k">if</span> (e.message.<span class="pl-c1">indexOf</span>(<span class="pl-s"><span class="pl-pds">'</span>ENOENT<span class="pl-pds">'</span></span>) <span class="pl-k">===</span> <span class="pl-c1">0</span>){
        ...
    }
    <span class="pl-k">if</span> (e.message.<span class="pl-c1">indexOf</span>(<span class="pl-s"><span class="pl-pds">'</span>PROCESS_ERROR_XXX<span class="pl-pds">'</span></span>) <span class="pl-k">===</span> <span class="pl-c1">0</span> ){
        ...
    }
})
.<span class="pl-c1">go</span>()
</pre></div>

<p>That's all core functions of <code>Action</code> is going to give you, hope you enjoy my solution :), Check <a href="https://github.com/winterland1989/Action.js/wiki/API-document">API doc</a> for more interesting things like <code>Action.parallel</code>, <code>Action.race</code>, <code>Action.sequence</code> and <code>Action.retry</code>, It's also highly recommend to read <a href="https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise">Difference from Promise</a> to get a deeper understanding.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/winterland1989/Action.js">Action.js</a> is maintained by <a href="https://github.com/winterland1989">winterland1989</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
