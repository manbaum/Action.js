{"name":"Action.js","tagline":"A sane way to write async code","body":"Action.js, a sane way to write async code\r\n=========================================\r\n    \r\n+ [FAQ](#FAQ)\r\n+ [API document](https://github.com/winterland1989/Action.js/wiki/API-document)\r\n+ [Difference from Promise](https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise)\r\n+ Usage: \r\n    + `npm i action-js` and `var Action = require('action-js')`.\r\n    + `git clone https://github.com/winterland1989/Action.js.git` and `var Action = require('Action.js')`.\r\n    + Add a script tag and use `window.Action`.\r\n\r\n+ Highlights:\r\n    + [Faster](https://github.com/winterland1989/Action.js/wiki/Benchmark) and simpler(~1kB minified gzipped)\r\n    + Full control capability with `retry`, `parallel`, `race`, `sequence` and more.\r\n    + Bundled with `ajax`, `jsonp` for front-end usage.\r\n\r\nUnderstand Action.js in 5 minutes\r\n---------------------------------\r\n\r\nSuppose we want to solve the nest callback problem form scratch, there's an async function called `readFile`, and we want to use it to read `data.txt`, we have to supply a `callback` to it:\r\n\r\n```js\r\n// suppose this simple readFile never fail\r\nreadFile(\"data.txt\", function(data){\r\n    console.log(data);\r\n});\r\n```\r\n\r\nInstead we don't give a callback(the `console.log`) to it right now, we save this read action in a new `Action`:\r\n\r\n```js\r\nvar Action = function(go) {\r\n    this._go = go;\r\n}\r\n\r\nvar readFileAction = new Action(\r\n    function(cb){\r\n        readFile(\"data.txt\", cb);\r\n    }\r\n);\r\n```\r\nWe have following objects on our heap:\r\n\r\n    +----------------+-------+\r\n    | readFileAction | ._go  | \r\n    +----------------+----+--+\r\n                          |\r\n                          v\r\n                    +----------+---------------+\r\n                    | function(cb)             |\r\n                    +----------+---------------+   \r\n                    | readFile(\"data.txt\", cb) |\r\n                    +--------------------------+\r\n\r\nOk, now we must have a way to extract the action from our `readFileAction`, let's using `readFileAction._go` directly:\r\n\r\n```js\r\nreadFileAction._go(function(data){\r\n    console.log(data);\r\n})\r\n```\r\n\r\nWhat above does is equivalent to what we write at beginning, right?:\r\n\r\n```js\r\nreadFile(\"data.txt\", function(data){\r\n    console.log(data);\r\n});\r\n```\r\n\r\nJust with one difference, we seperate action creation(wrap `readFile` in `new Action`) and application(supply a callback to `_go`), Now we want to chain more callbacks in Promise `then` style:\r\n\r\n```js\r\nAction.prototype._next = function(cb) {\r\n    var _go = this._go;\r\n    return new Action(function(_cb) {\r\n        return _go(function(data) {\r\n            var _data = cb(data);\r\n            return _cb(_data);\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nLet's break down `_next` a little here:\r\n\r\n+ `_next` accept a callback `cb`, and return a new `Action`.\r\n\r\n+ When the new `Action` fired with `_cb`, the original `Action`'s action will be fired first, and send the value to `cb`.\r\n\r\n+ We apply `cb` with `data` from the original `Action`\r\n\r\n+ Then we send the `_data` produced by `cb(data)` to `_cb`.\r\n\r\n+ The order is (original `Action`'s `_go`) --> (`cb` which `_next` received) --> (`_cb` we give to our new `Action`).\r\n\r\n+ Since we haven't fired our new `Action` yet, we haven't send the `_cb`, the whole callback chain is saved in our new `Action`.\r\n\r\nWith our `_next`, we can chain multiply callbacks and pass data between them:\r\n\r\n```js\r\nreadFileAction\r\n._next(function(data){\r\n    return data.length;\r\n})\r\n._next(function(data){\r\n    // data here is the length we obtain last step\r\n    console.log(data);\r\n    return length > 0\r\n})\r\n._go(function(data){\r\n    // data here is a Boolean\r\n    if(data){\r\n        ...\r\n    }\r\n})\r\n```\r\n\r\nLet's present it in a diagram:\r\n\r\n    +----------------+-------+\r\n    | ActionTwo      | ._go  | \r\n    +----------------+----+--+\r\n                          |\r\n                          v\r\n                    +----------+----------------+\r\n                    | function(cb_)             |\r\n                    +----------+----------------+  \r\n                    | cb = function(data){      |\r\n                    |   console.log(data);      |\r\n                    |   return length > 0       |\r\n                    | }                         |\r\n               +--- + ActionOne._go(            |\r\n               |    |   function(data){         |\r\n               |    |     cb_(cb(data))         |\r\n               |    |   });                     | \r\n               |    +---------------------------+\r\n               |                            \r\n               v       \r\n    +----------------+-------+            \r\n    | ActionOne      | ._go  | \r\n    +----------------+----+--+\r\n                          |\r\n                          v\r\n                    +----------+----------------+\r\n                    | function(cb_)             |\r\n                    +----------+----------------+  \r\n                    | cb = function(data){      |\r\n                    |   return data.length      |\r\n                    | }                         |\r\n               +--- + readFileAction._go(       |\r\n               |    |   function(data){         |\r\n               |    |     cb_(cb(data))         |\r\n               |    |   });                     | \r\n               |    +---------------------------+\r\n               |           \r\n               v          \r\n    +----------------+-------+\r\n    | readFileAction | ._go  | \r\n    +----------------+----+--+\r\n                          |\r\n                          v\r\n                    +----------+---------------+\r\n                    | function(cb)             |\r\n                    +----------+---------------+   \r\n                    | readFile(\"data.txt\", cb) |\r\n                    +--------------------------+\r\n\r\n`ActionOne` and `ActionTwo` are `Action`s first and second `_next` returned respectively, Now if we give `ActionTwo` a callback with `_go`, the whole callback chain will be fired sequential.\r\n\r\nNice, we just use a simple class with only one field, one very simple functions, the callbacks are now written in a much more readable way, but we have a key problem to be solved yet: what if we want to nest async `Action` inside an `Action`? Turn out with a little modification to our `_next` function, we can handle that:\r\n\r\n```js\r\nAction.prototype._next = function(cb) {\r\n    var _go = this._go;\r\n    return new Action(function(_cb) {\r\n        return _go(function(data) {\r\n            var _data = cb(data);\r\n            if (_data instanceof Action) {\r\n                return _data._go(_cb);\r\n            } else {\r\n                return _cb(_data);\r\n            }\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nWe use `instanceof Action` to check if `cb` returns an `Action` or not, if an `Action` is returned, we fire it with `_cb`, the callback which our new `Action` will going to receive:\r\n\r\n```js\r\nreadFileAction\r\n._next(function(data){\r\n    var newFile = parse(data);\r\n    return new Action(function(cb){\r\n        readFile(newFile, cb);\r\n    });\r\n})\r\n._go(function(data){\r\n    // data here is the newFile's content\r\n    console.log(data)\r\n})\r\n```\r\n\r\nNow we can say we have solved the callback hell problem! Well, actually just 50% of it.\r\nBefore we proceed another 50%, one important thing to keep in mind: **an `Action` is not a `Promise`, it will not happen if you don't fire it with `_go`, and it can be fired multiple times, it's just a reference to a wrapped function**:\r\n\r\n```js\r\nreadFileAction\r\n._next(processOne)\r\n._go(console.log)\r\n\r\n// after we do other things, or inside another request handler\r\n...\r\n\r\n// processTwo may receive different data since the file may change!\r\nreadFileAction\r\n._next(processTwo)\r\n._go(console.log)\r\n```\r\n\r\nI'll present `Action.freeze` in [Difference from Promise](https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise) to give you `Promise` behavior when you need it, now let's attack another 50% of the callback hell issue.\r\n\r\nError handling\r\n--------------\r\n\r\nOne biggest issue with `Promise` is that error handleing is somewhat magic and complex:\r\n\r\n+ It will eat your error sliently if you don't supply a `catch` at the end of the chain.\r\n\r\n+ You have to use two different functions, `resolve` to pass value to the callbacks and `reject` to skip them, what will happen if you `throw` an `Error`, well, just the same as `reject`.\r\n\r\nWhat we can do to make it simpler? It's a complex problem, we start solving it by simplify it: **Action.js use `Error` type as a special type to pass error information to the downstream**, what does this mean?\r\n\r\n```js\r\nAction.prototype.next = function(cb) {\r\n    var _go = this._go;\r\n    return new Action(function(_cb) {\r\n        return _go(function(data) {\r\n            if (data instanceof Error) {\r\n                return _cb(data);\r\n            } else {\r\n                var _data = cb(data);\r\n                if (_data instanceof Action) {\r\n                    return _data._go(_cb);\r\n                } else {\r\n                    return _cb(_data);\r\n                }\r\n            }\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nHere, let me present the final version of our `next` function, comparing to `_next` we write before, can you see what's the different? \r\n\r\n+ It still reture a new `Action`, when it fired, the original action are called.\r\n\r\n+ We checked if the `data` coming from upstream is `instanceof Error`, if it's not, everything as usual, we feed it to `cb` that `next` received.\r\n\r\n+ But if it's an `Error`, we skip `cb`, pass it to a future `_cb`, which we don't have now.\r\n\r\n`next` ensure the `cb` it received, **will never receive an `Error`**, we just skip `cb` and pass `Error` downstream, Symmetrically, we define a function which only deal with `Error`, and let normal values pass:\r\n\r\n```js\r\nAction.prototype.guard = function(cb) {\r\n    var _go = this._go;\r\n    return new Action(function(_cb) {\r\n        return _go(function(data) {\r\n           if (data instanceof Error) {\r\n            var _data = cb(data);\r\n                if (_data instanceof Action) {\r\n                    return _data._go(_cb);\r\n                } else {\r\n                    return _cb(_data);\r\n                }\r\n            } else {\r\n                return _cb(data);\r\n            }\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nThis time, we know the `cb` that `guard` received are prepared for `Error` values, so we flip the logic, you can also return an `Action` if your need some async code to deal with the `Error`.\r\n\r\nFollowing code demonstrate how to use our `next` and `guard`:\r\n\r\n```js\r\nnew Action(function(cb){\r\n    readFile('fileA', function(err, data){\r\n        if (err){\r\n            // see how to pass an Error to downstream\r\n            // not reject, not throw, just pass it on, let it go\r\n            cb(err);\r\n        }else{\r\n            cb(data);\r\n        }\r\n    });\r\n})\r\n.next(function(data){\r\n    // sync process\r\n    return processData(data);\r\n})\r\n.next(function(data){\r\n    // async process\r\n    return new Action(function(cb){\r\n        processDataAsync(data, cb);\r\n    })\r\n})\r\n.next(\r\n    try{\r\n        return someProcessMayWentWrong(data);\r\n    }catch(e){\r\n        // same as above, we return the error to pass it on\r\n        return e;\r\n    }\r\n}))\r\n.next(function(data){\r\n    // This process will be skip if previous steps pass an Error\r\n    return anotherProcess(data);\r\n})\r\n.guard(function(e){\r\n    // This process will be skip if there's no Errors\r\n    return processError(e);\r\n});\r\n._go(console.log);\r\n\r\n```\r\n\r\nThe final result will be produced by `anotherProcess` if `someProcessMayWentWrong` didn't go wrong and `readFile` didn't fail, otherwise it will be produced by `processError`.\r\n\r\nYou can place `guard` in the middle of the chain, all `Errors` before it will be handled by it, and the value it produced, sync or async, will be passed to the rest of the chain.\r\n\r\nSo, what if we don't supply a `guard`? Since we have to supply a callback to `_go`, we can check if the final result is an `Error` or not like this:\r\n\r\n```js\r\napiReturnAction('...')._go(function(data){\r\n    if (data instanceof Error){\r\n        //handle error here\r\n        ...\r\n    } else {\r\n        // process data here\r\n        ...\r\n    }\r\n});\r\n\r\n```\r\n\r\nYeah, it does work(and sometimes you want it work in this way), but:\r\n\r\n+ we don't want to force our user to supply a `cb` like above.\r\n\r\n+ we should throw `Error` in case user didn't `guard` them.\r\n\r\nSo here let me present the final version of `go`:\r\n\r\n```js\r\nAction.prototype.go = function(cb) {\r\n    return this._go(function(data) {\r\n        if (data instanceof Error) {\r\n            throw data;\r\n        } else if (cb != null) {\r\n            return cb(data);\r\n        }\r\n    });\r\n};\r\n\r\n```\r\n\r\nNow user can omit the callback, and if user don't guard `Error`s, we will yell at them when `Error` occurs!\r\n\r\n```js\r\nnew Action(function(cb){\r\n    readFile('fileA', function(err, data){\r\n        if (err){\r\n            // suppose we got an Error here\r\n            cb(err);\r\n        }else{\r\n\r\n            cb(data);\r\n        }\r\n    });\r\n})\r\n.go() // The Error will be thrown!\r\n\r\n```\r\n\r\nFinally, to ease error management, and to attack the [v8 optimization problems](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#2-unsupported-syntax). We recommand using `Action.safe`:\r\n\r\n```js\r\n// this small function minimize v8 try-catch overhead\r\n// and make attaching custom Error easy\r\nAction.safe = function(err, fn) {\r\n    return function(data) {\r\n        try {\r\n            return fn(data);\r\n        } catch (_error) {\r\n            return err;\r\n        }\r\n    };\r\n};\r\n```\r\n\r\nAnd use `safe` wrap your `someProcessMayWentWrong` like this:\r\n\r\n```js\r\nvar safe = Action.safe;\r\nnew Action(function(cb){\r\n    readFile('fileA', function(err, data){\r\n        if (err){\r\n            cb(err);\r\n        }else{\r\n            cb(data);\r\n        }\r\n    });\r\n})\r\n.next(\r\n    safe( new Error(\"PROCESS_ERROR_XXX: process xxx failed when xxx\")\r\n        , someProcessMayWentWrong)\r\n)\r\n.next(...)\r\n.next(...)\r\n.guard(function(e){\r\n    if (e.message.indexOf('ENOENT') === 0){\r\n        ...\r\n    }\r\n    if (e.message.indexOf('PROCESS_ERROR_XXX') === 0 ){\r\n        ...\r\n    }\r\n})\r\n.go()\r\n\r\n```\r\n\r\nThat's all core functions of `Action` is going to give you, thank you for reading, how long does it take you? hope you enjoy my solution :)\r\n\r\n+ Check [API doc](https://github.com/winterland1989/Action.js/wiki/API-document) for interesting things like `Action.parallel`, `Action.race`, `Action.sequence` and `Action.retry`.\r\n\r\n+ Read [Difference from Promise](https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise) to get a deeper understanding.\r\n\r\nFAQ<a name=\"FAQ\"></a>\r\n=====================\r\n\r\nWhat makes `Action` faster than `Promise`?\r\n------------------------------------------\r\n\r\nBecause it simply does less work:\r\n\r\n+ It doesn't maintain any internal state.\r\n\r\n+ It just have a single field, which is a reference to a function.\r\n\r\n+ It just add a redirect call to original callback, and some type checking.\r\n\r\nI even be amazed it can achieve so much functionality with such short code myself, see [Benchmark](https://github.com/winterland1989/Action.js/wiki/Benchmark) youself.\r\n\r\nWhy following code doesn't work?\r\n--------------------------------\r\n\r\n```js\r\nvar fileA = readFileAction\r\n.go(processOne)\r\n\r\nfileA\r\n.next(processTwo)\r\n.go()\r\n```\r\n\r\nWell, read [Difference from Promise](https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise) to get a detailed answer, tl,dr... here is the short answer:\r\n\r\n```js\r\n// readFile now and return a Action, this function won't block\r\nvar fileA = Action.freeze(readFileAction.next(processOne))\r\n\r\n// now fileA will always have the same content\r\n// and file will never be read again.\r\nfileA\r\n.next(processTwo)\r\n.go()\r\n\r\n// processTwo will receive the same content\r\nfileA\r\n.next(processTwo)\r\n.go()\r\n```\r\n\r\nIf you want have a `Promise` behavior(fire and memorize), use `Action.freeze`, `go` won't return a new `Action`.\r\n\r\nWhen to use this library?\r\n-------------------------\r\n\r\nWith `Promise` added to ES6 and ES7 `async/await` proposal, one must ask, why another library to do the same things again?\r\n\r\nI actually can add generator support with something like `Action.async` when ES6 come to most browser, but i can see future will be full of `async` functions all over the place, use this library if you:\r\n\r\n+ Have a FP background, you must find all i have done is porting the `Cont` monad from Haskell, and i believe you have divided your program into many composable functions already, just connect them with `next`.\r\n\r\n+ Want something small and memory effient in browser.\r\n\r\n+ Want to control exactly when the action will run, with `Promise`, all action run in next tick, While with `Action`, action runs when you call `go`, `_go` or `Action.freeze`. \r\n\r\n+ Want a different sementics, with `Promise`, you just can't reuse your callback chain, you have to create a new `Promise`, with `Action`, just `go` again, never waste memory on GC. \r\n\r\n    Consider following code, and try to rewrite it with `Promise`:\r\n\r\n    ```js\r\n    Action.retry = function(times, action) {\r\n        var a;\r\n        return a = action.guard(function(e) {\r\n            if (times-- !== 0) {\r\n                return a;\r\n            } else {\r\n                return new Error('RETRY_ERROR: Retry limit reached');\r\n            }\r\n        });\r\n    };\r\n    ```\r\n\r\n+ Want raw speed, this is somehow not really an issue, most of the time, `Promise` or `Action` won't affect that much, nevertheless, `Action.js` can guarantee speed close to handroll callbacks, just much cleaner.\r\n\r\nHow can i send an `Error` to downstream's `next`\r\n------------------------------------------------\r\n\r\nNo, you can't, you have to wrap it in a `Array` or `Object` or `Map`...whatever, the choice of using `Error` to skip `next` and hit `guard` is not arbitrary, instead of creating an `ActionError` class, use `Error` unify type with system runtime, and providing callstack information.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}