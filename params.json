{"name":"Action.js","tagline":"A sane way to write async code","body":"Action.js, a fast, small, full feature async library\r\n====================================================\r\n    \r\n+ [FAQ](#FAQ)\r\n+ [Changelog](#Changelog)\r\n+ [Benchmark](https://github.com/winterland1989/Action.js/wiki/Benchmark)\r\n+ [API document](https://github.com/winterland1989/Action.js/wiki/API-document)\r\n+ Usage: \r\n    + `npm i action-js` and `var Action = require('action-js')`.\r\n    + Clone this repo and use `Action.js` and `ajaxHelper.js` with AMD or CMD loader, bundler.\r\n    + Add a script tag and use `window.Action`.\r\n\r\n+ Highlights:\r\n    + [Blazing fast](https://github.com/winterland1989/Action.js/wiki/Benchmark) and extremly small(4.2k/minified 1.4k/gzipped)\r\n    + Full feature APIs like `retry`, `parallel`, `race`, `throttle` and more.\r\n    + [Cancellable](https://github.com/winterland1989/Action.js/wiki/Return-value-of-go) and [retriable](https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise) semantics.\r\n    + `Action.co` to work with generator functions.\r\n    + [Signal and pump](https://github.com/winterland1989/Action.js/wiki/Signal-And-Pump) provides easy and composable async UI management(form validation...).\r\n\r\n+ Eco-system:\r\n    + [ajax-action](https://github.com/winterland1989/ajax-action)\r\n\r\nWhat is `Action`\r\n----------------\r\n\r\nInterested? `Action` is a fast and clean alternative to both `Promise`(and `Observable` if you'd like to), it's intended to solve what `Promise` can't solve:\r\n\r\n+ Can't run async actions without reallocate new instances, see [lazy promise](https://github.com/petkaantonov/bluebird/issues/812), [throttling](https://github.com/petkaantonov/bluebird/issues/570).\r\n\r\n+ Sliently eat errors, see [Unhandled Rejection](https://github.com/nodejs/node/issues/830), and [related hack](https://github.com/nodejs/node/issues/5084).\r\n\r\nBesides all the benifits, `Action` run at blazing fast speed with simpler and smaller code. A simple example:\r\n\r\n```js\r\nvar Action = require('action-js');\r\nnew Action(function(cb){\r\n    readFile('fileA', function(err, data){\r\n        if (err){\r\n            cb(err);\r\n        }else{\r\n            cb(data);\r\n        }\r\n    });\r\n})\r\n.next(function(data){\r\n    // sync process\r\n    return processData(data);\r\n})\r\n.next(function(data){\r\n    // async process\r\n    return new Action(function(cb){\r\n        processDataAsync(data, cb);\r\n    })\r\n})\r\n.next(function(data){\r\n    // This process will be skip if previous steps pass an Error\r\n    return anotherProcess(data);\r\n})\r\n.guard(function(e){\r\n    // This process will be skip if there's no Errors\r\n    return processError(e);\r\n});\r\n.go(function(data){console.log data});\r\n```\r\n\r\nIt looks like `Promise` with some differences:\r\n\r\n+ Add a `go` call when you want to fire an `Action`, and you can fire multiple times, which means `Action`'s lazily executed, so you can do retry/throttle...\r\n\r\n+ If you come across an `Error`, just pass it down like normal values, see `safe/safeRaw` in next chapter.\r\n\r\n+ `next` only pass none `Error` value to its callback, and `guard` only call its callback if upstream pass `Error` down, if you'd like to handled `Error` and normal value inside one callback, use `_next`. \r\n\r\n+ `Error` will never be swallowed, and now you can use `throw` to break your program if you really want to.\r\n\r\nYou can also use `makeNodeAction` to replace `promisify` in other promise library, let's get into the core since now you must have a lot of questions.\r\n\r\nHow does `Action` works\r\n-----------------------\r\n\r\n`Action`'s core is an extremly simple javascript class(to mimic haskell's `newtype`):\r\n\r\n```js\r\nvar Action = function(go) {\r\n    this._go = go;\r\n}\r\n```\r\n\r\nWe construct an `Action` by passing a function which consume a callback(aka. contination), take `fs.readFile` as an example:\r\n\r\n```js\r\n// suppose this readFile never fail\r\n// we will talk error handleing later\r\nvar readFileAction = new Action(function(cb){\r\n    fs.readFile('data.txt', function(err, data){\r\n        cb(data);\r\n    })\r\n});\r\n```\r\n\r\nNow if we provide a callback to `readFileAction._go`:\r\n\r\n```js\r\nreadFileAction._go(function(err, data){\r\n    console.log(data);\r\n})\r\n```\r\n\r\nThe callback chain will be fired, it's equivalent to following code:\r\n\r\n```js\r\nreadFile(\"data.txt\", function(data){\r\n    console.log(data);\r\n});\r\n```\r\n\r\nWith one difference, `Action` seperate contination creation(wrap `readFile` in `new Action`) and application(supply a callback to `_go`), that's the core idea of `Action`, **an Action always wrap a contination inside**. \r\n\r\nNow we can add a method to compose another callback with this contination:\r\n\r\n```js\r\nAction.prototype._next = function(cb) {\r\n    var self = this;\r\n    return new Action(function(_cb) {\r\n        return self._go(function(data) {\r\n            var _data = cb(data); // this cb is what we pass to next\r\n            return _cb(_data); // this _cb has not been passed yet!\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nLet's break down `_next` a little here:\r\n\r\n+ `_next` accept a callback `cb`, and return a new `Action`.\r\n\r\n+ When the new `Action` fired with `_cb`, the original `Action`'s action will be fired first, and send the value to `cb`, then send the `_data` produced by `cb(data)` to `_cb`.\r\n\r\n+ The order is (original `Action`'s `_go`) --> (`cb` which `_next` received) --> (`_cb` we give to our new `Action`).\r\n\r\n+ Since we haven't fired our new `Action` yet, we haven't got the `_cb`, the whole contination is saved in our new `Action`.\r\n\r\nWith our `_next`, we can chain multiply callbacks, note how data flows between them:\r\n\r\n```js\r\nreadFileAction\r\n._next(function(data){\r\n    return data.length;\r\n})\r\n._next(function(data){\r\n    // data here is the length we obtain last step\r\n    console.log(data);\r\n    return length > 0\r\n})\r\n._go(function(data){\r\n    // data here is a Boolean\r\n    if(data){\r\n        ...\r\n    }\r\n})\r\n```\r\n\r\nEach `_next` return a new `Action`, if we give the final `Action` a callback with `_go`, the whole callback chain will be fired sequential.\r\n\r\nNice, we just use a very simple class, one very simple functions, the callbacks are written in a much more readable way now, but we have a key problem to be solved yet: what if we want to nest async `Action` inside an `Action`? Turn out with a little modification to our `_next` function, we can handle that:\r\n\r\n```js\r\nAction.prototype._next = function(cb) {\r\n    var self = this;\r\n    return new Action(function(_cb) {\r\n        return self._go(function(data) {\r\n            var _data = cb(data);\r\n            if (_data instanceof Action) {\r\n                return _data._go(_cb);\r\n            } else {\r\n                return _cb(_data);\r\n            }\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nThis's the core of composable contination, We use `instanceof Action` to check if `cb` returns an `Action` or not, if an `Action` is returned, we fire it with `_cb`, the callback which our new `Action` will going to receive:\r\n\r\n```js\r\nreadFileAction\r\n._next(function(data){\r\n    var newFile = parse(data);\r\n    return new Action(function(cb){\r\n        readFile(newFile, cb);\r\n    });\r\n})\r\n._go(function(data){\r\n    // data here is the newFile's content\r\n    console.log(data)\r\n})\r\n```\r\n\r\nNow we have solved the callback hell problem! Well, actually just 50% of it.\r\nBefore we proceed another 50%, one important thing to keep in mind: **an `Action` is not a `Promise`, it will not happen if you don't pass a callback to `_go`, and it can be fired multiple times, it's just a reference to a wrapped contination**:\r\n\r\n```js\r\nreadFileAction\r\n._next(processOne)\r\n._go(console.log)\r\n\r\n// after we do other things, or inside another request handler\r\n...\r\n\r\n// processTwo may receive different data since the file may change!\r\nreadFileAction\r\n._next(processTwo)\r\n._go(console.log)\r\n```\r\n\r\nI'll present `Action.freeze` in [Difference from Promise](https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise) to give you `Promise` behavior when you need it, now let's attack another 50% of the callback hell issue.\r\n\r\nError handling\r\n--------------\r\n\r\nOne biggest issue with `Promise` is that error handleing is somewhat magic and complex:\r\n\r\n+ It will eat your error sliently if you don't supply a `catch` at the end of the chain.\r\n\r\n+ You have to use two different functions, `resolve` to pass value to the callbacks and `reject` to skip them, what will happen if you `throw` an `Error`, well, just the same as `reject`.\r\n\r\n+ You lost the ability to break your program by throwing, sometime you do need it.\r\n\r\nWhat we can do to make it simpler? It's a complex problem, we start solving it by simplify it: **Action.js use `Error` type as a special type to pass error information to the downstream**, what does this mean?\r\n\r\n```js\r\nAction.prototype.next = function(cb) {\r\n    var self = this;\r\n    return new Action(function(_cb) {\r\n        return self._go(function(data) {\r\n            if (data instanceof Error) {\r\n                return _cb(data); // we directly skip cb here\r\n            } else {\r\n                var _data = cb(data);\r\n                if (_data instanceof Action) {\r\n                    return _data._go(_cb);\r\n                } else {\r\n                    return _cb(_data);\r\n                }\r\n            }\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nLet me present the final version of our `next` function, comparing to `_next` we write before:\r\n\r\n+ It still reture a new `Action`, when it fired, the original action are called.\r\n\r\n+ We checked if the `data` coming from upstream is `instanceof Error`, if it's not, everything as usual, we feed it to `cb` that `next` received. But if it's an `Error`, we skip `cb`, pass it directly to `_cb`.\r\n\r\n`next` ensure the `cb` it received, **will never receive an `Error`**, we just skip `cb` and pass `Error` downstream, symmetrically, we define a function which only deal with `Error`, and let normal values pass:\r\n\r\n```js\r\nAction.prototype.guard = function(cb) {\r\n    var self = this;\r\n    return new Action(function(_cb) {\r\n        return self._go(function(data) {\r\n           if (data instanceof Error) {\r\n            var _data = cb(data);\r\n                if (_data instanceof Action) {\r\n                    return _data._go(_cb);\r\n                } else {\r\n                    return _cb(_data);\r\n                }\r\n            } else {\r\n                return _cb(data);\r\n            }\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nThis time, the `cb` that `guard` received are prepared for `Error` values, so we flip the logic, you can also return an `Action` if your need some async code to deal with the `Error`. Actually `guard` can receive an extra parameter before `cb` to filter what kind of `Error` `cb` can deal with, check out [source code](https://github.com/winterland1989/Action.js/blob/master/Action.coffee#L27)/[api doc](https://github.com/winterland1989/Action.js/wiki/API-document#actionprototypeguardcb--error---b).\r\n\r\nFollowing code demonstrate how to use our `next` and `guard`:\r\n\r\n```js\r\nnew Action(function(cb){\r\n    readFile('fileA', function(err, data){\r\n        if (err){\r\n            // see how to pass an Error to downstream\r\n            // not reject, not throw, just pass it on, let it go\r\n            cb(err);\r\n        }else{\r\n            cb(data);\r\n        }\r\n    });\r\n})\r\n.next(function(data){\r\n    // sync process\r\n    return processData(data);\r\n})\r\n.next(function(data){\r\n    // async process\r\n    return new Action(function(cb){\r\n        processDataAsync(data, cb);\r\n    })\r\n})\r\n.next(\r\n    try{\r\n        return someProcessMayWentWrong(data);\r\n    }catch(e){\r\n        // same as above, we return the error to pass it on\r\n        return e;\r\n    }\r\n}))\r\n.next(function(data){\r\n    // This process will be skip if previous steps pass an Error\r\n    return anotherProcess(data);\r\n})\r\n.guard('ENOENT', function(e){\r\n    // This process will be called only when Error's message begin with 'ENOENT'\r\n    return processENOENT(e);\r\n});\r\n.guard(function(e){\r\n    // This process will be skip if there's no Errors\r\n    return processError(e);\r\n})\r\n._go(console.log);\r\n\r\n```\r\n\r\nThe final result will be produced by `anotherProcess` if `someProcessMayWentWrong` didn't go wrong and `readFile` didn't fail, otherwise it will be produced by `processError`.\r\n\r\nYou can place `guard` in the middle of the chain, all `Errors` before it will be handled by it, and the value it produced, sync or async, will be passed down to the rest of the chain.\r\n\r\nWhat if we don't supply a `guard`? Since we have to supply a callback to `_go`, we can check if the final result is an `Error` or not like this:\r\n\r\n```js\r\napiReturnAction('...')._go(function(data){\r\n    if (data instanceof Error){\r\n        //handle error here\r\n        ...\r\n    } else {\r\n        // process data here\r\n        ...\r\n    }\r\n});\r\n\r\n```\r\n\r\nYeah, it does work, and often you want it work in this way, but:\r\n\r\n+ sometime we don't want to supply a `cb`.\r\n\r\n+ we should throw `Error` in case user didn't `guard` them.\r\n\r\nSo here let me present the final version of `go`:\r\n\r\n```js\r\nAction.prototype.go = function(cb) {\r\n    return this._go(function(data) {\r\n        if (data instanceof Error) {\r\n            throw data;\r\n        } else if (cb != null) {\r\n            return cb(data);\r\n        }\r\n    });\r\n};\r\n\r\n```\r\n\r\nNow user can omit the callback, and if user don't guard `Error`s, we will yell at them when `Error` occurs!\r\n\r\n```js\r\nnew Action(function(cb){\r\n    readFile('fileA', function(err, data){\r\n        if (err){\r\n            // suppose we got an Error here\r\n            cb(err);\r\n        }else{\r\n            cb(data);\r\n        }\r\n    });\r\n})\r\n.go() // The Error will be thrown!\r\n\r\n```\r\n\r\nFinally, to ease error management, and attack the [v8 optimization problems](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#2-unsupported-syntax). We recommand using `Action.safe`:\r\n\r\n```js\r\n// this small function minimize v8 try-catch overhead\r\n// and make attaching custom Error easy\r\nAction.safe = function(err, fn) {\r\n    return function(data) {\r\n        try {\r\n            return fn(data);\r\n        } catch (_error) {\r\n            return err;\r\n        }\r\n    };\r\n};\r\n```\r\n\r\nUse `safe` wrap your `someProcessMayWentWrong` like this:\r\n\r\n```js\r\nvar safe = Action.safe;\r\nnew Action(function(cb){\r\n    ...\r\n})\r\n.next(\r\n    safe(new Error(\"PROCESS_ERROR_XXX: process xxx failed when xxx\")\r\n        , someProcessMayWentWrong)\r\n)\r\n.next(...)\r\n.guard(function(e){\r\n    if (e.message.indexOf('ENOENT') === 0){\r\n        ...\r\n    }\r\n    if (e.message.indexOf('PROCESS_ERROR_XXX') === 0 ){\r\n        ...\r\n    }\r\n})\r\n.go()\r\n\r\n```\r\n\r\nThat's all core functions of `Action`, but it's much more powerful than first look! make sure you read:\r\n\r\n+ [Difference from Promise](https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise) to get a deeper understanding.\r\n\r\n+ [Return value of go](https://github.com/winterland1989/Action.js/wiki/Return-value-of-go) to learn how to cancel an `Action`.\r\n\r\n+ [Signal and pump](https://github.com/winterland1989/Action.js/wiki/Signal-and-pump) to see how `Action` making async UI management easy.\r\n\r\n+ [API doc](https://github.com/winterland1989/Action.js/wiki/API-document) for interesting things like `Action.parallel`, `Action.race`, `Action.throttle` and `Action.retry`.\r\n\r\n+ [ajax-action](https://github.com/winterland1989/ajax-action) for front-end needs like `ajax`, `jsonp` and `parseParam/buildParam`.\r\n\r\nFAQ<a name=\"FAQ\"></a>\r\n=====================\r\n\r\nWhen to use this library?\r\n-------------------------\r\n\r\nWith `Promise` added to ES6 and ES7 `async/await` proposal, one must ask, why another library to do the same things again?\r\n\r\nBecause `Action` is not `Promise`, It's a faster, simpler and full feature alternative comes with more flexible semantics. Actually `Action` have a [very elegant `Action.co` implementation](https://github.com/winterland1989/Action.js/blob/master/Action.coffee#L234) to work with generators, nevertheless, use this library if you:\r\n\r\n+ Want something small, fast and memory effient in browser.\r\n\r\n+ Want to manage complex async UI, read [Signal and pump](https://github.com/winterland1989/Action.js/wiki/Signal-and-pump) to get a modular solution to async UI management.\r\n\r\n+ Want manage cancellable actions, read the [Return value of go](https://github.com/winterland1989/Action.js/wiki/Return-value-of-go) to get an elegant solution to cancellable actions.\r\n\r\n+ Want a different sementics, with `Promise`, you just can't reuse your callback chain, you have to create a new `Promise`, with `Action`, just `go` again, never waste memory on GC. \r\n\r\n+ Want to control exactly when the action will run, with `Promise`, all action run in next tick, While with `Action`, action runs when you call `go`, `_go` or `Action.freeze`.\r\n\r\n+ Want raw speed, this is somehow not really an issue, most of the time `Promise` or `Action` won't affect that much, nevertheless, `Action.js` can guarantee speed close to handroll callbacks in any runtime, just much cleaner.\r\n\r\nIf you have a FP background, you must find all i have done is porting the `Cont` monad from Haskell, and i believe you have divided your program into many composable functions already, just connect them with `next`.\r\n\r\nThe semantics of `Action` also fit varieties situations like animation and interactive UI, it's far more suitable than `Promise` in these situations.\r\n\r\nWhat makes `Action` fast?\r\n-------------------------\r\n\r\nCheck out [Benchmark](https://github.com/winterland1989/Action.js/wiki/Benchmark), even use bluebird's benchmark suit, which heavily depend on library's [promisify](https://github.com/petkaantonov/bluebird/blob/master/src/promisify.js#L124) implementation, `Action` can match bluebird's performance.\r\n\r\nGenerally speaking, `Action` simply does less work:\r\n\r\n+ It doesn't maintain any internal state.\r\n\r\n+ It just have a single field, which is a reference to a function.\r\n\r\n+ It just add a redirect call to original callback, and some type checking.\r\n\r\nWhy following code doesn't work?\r\n--------------------------------\r\n\r\n```js\r\nvar fileA = readFileAction\r\n.go(processOne)\r\n\r\n// Error, fileA is not an Action anymore\r\nfileA\r\n.next(processTwo)\r\n.go()\r\n```\r\n\r\nWell, read [Difference from Promise](https://github.com/winterland1989/Action.js/wiki/Difference-from-Promise) and [Return value of go](https://github.com/winterland1989/Action.js/wiki/Return-value-of-go) to get a detailed answer, tl,dr... here is the short answer:\r\n\r\n```js\r\n// readFile now and return a Action, this function won't block\r\nvar fileA = Action.freeze(readFileAction.next(processOne))\r\n\r\n// now fileA will always have the same content\r\n// and file will never be read again.\r\nfileA\r\n.next(processTwo)\r\n.go()\r\n\r\n// processTwo will receive the same content\r\nfileA\r\n.next(processTwo)\r\n.go()\r\n```\r\n\r\nIf you want have a `Promise` behavior(fire and memorize), use `Action.freeze`, `go` won't return a new `Action`, instead `go` return a cancel handler if underline action can be cancelled.\r\n\r\nHow can i send an `Error` to downstream's `next`\r\n------------------------------------------------\r\n\r\nNo, you can't, however, you can receive `Error` from upstream use `_next`, `_go` or `guard`. or you can wrap the `Error` in an `Array` like `[e]`, it's a very rare situation one want to process a `Error` value like normal values.\r\n\r\nThe choice of using `Error` to skip `next` and hit `guard` is not arbitrary, instead of creating an `ActionError` class, use `Error` unify type with system runtime, and providing callstack information. And you can now break your program by throwing an Error if you really want to.\r\n\r\nChangelog<a name=\"Changelog\"></a>\r\n=================================\r\n\r\nV4.2.1\r\nSeperate ajax related stuff into seperate package, [ajax-action](https://github.com/winterland1989/ajax-action).\r\n\r\nV4.2.0\r\n`prototype.guard` now accpet an extra parameter(before cb) to guard Error based on their message (prefix). \r\n\r\nV4.1.1\r\nSmall `throttle` optimization.\r\n\r\nV4.1.0\r\nAdd `throttle`, now `parallel` and `sequence` are implemented by `throttle`.\r\n\r\nv3.1.0\r\n\r\n1. Add `stopAtError` flag to `Action.join`.\r\n\r\n2. Change `ajaxHelpers.buildParam` behavior when input contain arrays, now `foo: [1,2,3]` will output `foo=1&foo=2&foo=3`.\r\n\r\nv3.0.0\r\nSeperate ajax related stuff into `ajaxHelper.js`.\r\n\r\nv2.4.2\r\nMake `prototype.go` default to id function if no callback is provided.\r\n\r\nv2.4.1\r\nFix a `Action.fuseSignal` bug.\r\n\r\nv2.4.0\r\nAdd `Action.signal` and `Action.fuseSignal` to ease async UI management.\r\n\r\nv2.3.0\r\nNow when you construct an `Action`, the `this` variable inside the contination will be the `Action` instance.\r\n\r\nv2.2.0\r\n`Action.join`, `Action.parallel`, `Action.race` now return an `Array` of cancel handler when the composed `Action` fired, you can now cancel them with ease. \r\n\r\nv2.1.1\r\nFix a bug of `Action.parallel`, add test. \r\n\r\nv2.1.0\r\nChange `Action.co` into more async-await style, you can use try-catch to catch `Error`s now.  \r\n\r\nv2.0.0\r\nUpdate doc, Remove `gapRetry`, since it's just a `retry` compose `delay`. \r\n\r\nv1.4.1\r\nRun bluebird benchmark, add some optimization.\r\n\r\nv1.4.0\r\nAdd Action.co, fix Action.join typos, test cover 100% agian.\r\n\r\nv1.3.0\r\nAdd Action.join, optimized internal\r\n\r\nv1.2.4\r\nImprove makeNodeAction\r\n\r\nv1.2.3\r\nFix responseType related.\r\n\r\nv1.2.2\r\nAuto add header based on data type.\r\n\r\nv1.2.1\r\nClear some error types.\r\n\r\nv1.2.0\r\nadd `param`, `jsonp` and `ajax` for front-end usage.\r\n\r\nLicense\r\n=======\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2016 Winterland\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}