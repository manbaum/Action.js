{"name":"Action.js","tagline":"A clean alternative to promise","body":"Action.js, a sane way to write async code\r\n=========================================\r\n\r\nPromise and async/await are all great stuff, but Action.js offer an alternative faster and more concise.\r\n\r\nUnderstand Action.js in 3 minutes\r\n---------------------------------\r\n\r\nLet's solve the callback hell proble form scratch, suppose we have a lovely function called `readFile`, and we want to read `data.txt`\r\n\r\n    readFile(\"data.txt\", callback)\r\n\r\nWe want compose different actions with this reading action, so we don't want to give a callback to it now, instead we save this action in a new `Action`:\r\n\r\n```js\r\nvar Action = function Action(action1) {\r\n    this.action = action1;\r\n}\r\n\r\nvar readFileAction = new Action(\r\n    function(cb){\r\n        readFile(\"data.txt\", cb);\r\n    }\r\n);\r\n```\r\nOk, now we must have a method to extract the action from our `readFileAction`, instead use `readFileAction.action` directly, we write a function to accpet a callback, and pass this callback to the action inside our `readFileAction`:\r\n```js\r\nAction.prototype._go = function(cb) {\r\n    return this.action(cb);\r\n};\r\nreadFileAction._go(function(data){\r\n    console.log(data);\r\n})\r\n```\r\nYou should understand what above `_go` does is equivalent to following:\r\n```js\r\nreadFile(\"data.txt\", function(data){\r\n    console.log(data);\r\n});\r\n```\r\nJust with one different, we seperate action creation(wrap `readFile` in `new Action`) and application(use `_go` to supply a callback), in fact we have successfully did a [CPS transformation](https://en.wikipedia.org/wiki/Continuation-passing_style), we will talk about that later.\r\n\r\nNow we want to chain callbacks in Promise `then` style:\r\n```js\r\nAction.prototype._next = function(cb) {\r\n    var self = this;\r\n    return new Action(function(_cb) {\r\n        return self.action(function(data) {\r\n            var _data = cb(data);\r\n            return _cb(_data);\r\n        });\r\n    });\r\n};\r\n```\r\nLet's break down a little here:\r\n\r\n+ `_next` should accept a callback `cb`, and return a new `Action`.\r\n+ When the new `Action` fired, the original `Action`'s action should be fired first, and send the value to `cb`.\r\n\r\nWith our `_next`, we can chain multiply callbacks and pass data between them:\r\n\r\n```js\r\nreadFileAction\r\n._next(function(data){\r\n    return data.length;\r\n})\r\n._next(function(data){\r\n    // data here is the length we obtain last step\r\n    console.log(data);\r\n    return length > 0\r\n})\r\n._go(function(data){\r\n    // data here is a Boolean\r\n    if(data){\r\n        ...\r\n    }\r\n})\r\n```\r\n\r\nNice, we just use two simple functions, and the callbacks can be written in a more readable way, but we have a very important problem to be solve yet: what if we want nest async `Action`s inside an `Action`, it turn out with an adjusted `_next` function, we can handle that:\r\n\r\n```js\r\nAction.prototype._next = function(cb) {\r\n    var self = this;\r\n    return new Action(function(_cb) {\r\n        return self.action(function(data) {\r\n            var _data = cb(data);\r\n            if (_data instanceof Action) {\r\n                return _data._go(_cb);\r\n            } else {\r\n                return _cb(_data);\r\n            }\r\n        });\r\n    });\r\n};\r\n```\r\nWe use `instanceof Action` to check if a callback returns a `Action` or not, if an `Action` is returned, we fire it with callbacks in future:\r\n\r\n```js\r\nreadFileAction\r\n._next(function(data){\r\n    var newFile = parse(data);\r\n    return new Action(function(cb){\r\n        readFile(newFile, cb);\r\n    });\r\n})\r\n._go(function(data){\r\n    // data here is the newFile's content\r\n    console.log(data)\r\n})\r\n```\r\nNow we can say we have solved the callback hell problem! well, actually just 50% of it.\r\nOne important thing to remember: **an `Action` is not happening if you don't fire it, and it can be fired multiple times, it's just a reference to a wrapped function**:\r\n```js\r\nreadFileAction\r\n._next(processOne)\r\n._go(console.log)\r\n\r\n// after we do other things, or inside another request handler\r\n...\r\n\r\n// processTwo may receive different data since the file may change!\r\nreadFileAction\r\n._next(processTwo)\r\n._go(console.log)\r\n```\r\n\r\nWe'll present `freeze` to fire an `Action` immediately, now let's face another 50% of the callback hell issue.\r\n\r\nError handling\r\n--------------\r\n\r\nOne biggest issue with `Promise` is the error handleing is somewhat magic and complex:\r\n\r\n+ It will eat your error sliently if you don't supply a `catch` at the end of the chain.\r\n+ You have to use two different functions, `resolve` to pass value to the callbacks and `reject` to skip them, what about `throw` an `Error`?\r\n\r\nWhat we can do to make it simpler? Well, it's a complex problem, so we start solving it by simplify it: **We use `Error` type as a special type to pass error information to the downstream**, what does this mean?\r\n\r\n```js\r\nAction.prototype.next = function(cb) {\r\n    var self = this;\r\n    return new Action(function(_cb) {\r\n        return self.action(function(data) {\r\n            if (data instanceof Error) {\r\n                return _cb(data);\r\n            } else {\r\n                var _data = cb(data);\r\n                if (_data instanceof Action) {\r\n                    return _data._go(_cb);\r\n                } else {\r\n                    return _cb(_data);\r\n                }\r\n            }\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nHere, let me present the final version of our `next` function, comparing to `_next` we write before, can you see what's the different? It still reture a new `Action`, when it fired, the original action are called, and we checked if the data are `instanceof Error`, if it's not, everything as usual, we feed it to `cb` that `next` received, but if it's an `Error`, we pass it to a future `_cb`, which we don't have now.\r\n\r\nSymmetrically, we have to define a function that special deal with `Errors`, and let normal values pass:\r\n\r\n```js\r\nAction.prototype.guard = function(cb) {\r\n    var self = this;\r\n    return new Action(function(_cb) {\r\n        return self.action(function(data) {\r\n           if (data instanceof Error) {\r\n            var _data = cb(data);\r\n                if (_data instanceof Action) {\r\n                    return _data._go(_cb);\r\n                } else {\r\n                    return _cb(_data);\r\n                }\r\n            } else {\r\n                return _cb(data);\r\n            }\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nThis time, we know the `cb` that `guard` received are prepared for `Error` values, so when we flip the logic.\r\n\r\nFollowing code demonstrate how to use our `next` and `guard`:\r\n\r\n```\r\nnew Action(function(cb){\r\n    readFile('fileA', function(err, data){\r\n        if (err){\r\n            // see how to pass an Error to downstream, not reject, not throw, just return\r\n            cb(err);\r\n        }else{\r\n\r\n            cb(data);\r\n        }\r\n    });\r\n})\r\n.next(function(data){\r\n    return processData(data);\r\n})\r\n.next(function(data){\r\n    return new Action(function(cb){\r\n        processDataAsync(data, cb);\r\n    })\r\n})\r\n.next(\r\n    try{\r\n        return someProcessMayWentWrong(data);\r\n    }catch(e){\r\n        // same as above, we return the error\r\n        return e;\r\n    }\r\n}))\r\n.next(function(data){\r\n    // This process will be skip if previous step pass an Error\r\n    return anotherProcess(data);\r\n})\r\n.guard(function(e){\r\n    // This process will be skip if there's no Errors\r\n    return processError(e);\r\n});\r\n._go(console.log);\r\n\r\n```\r\n\r\nThe final result will be produced by `anotherProcess` if `someProcessMayWentWrong` didn't go wrong, or produced by `processError` otherwise.\r\n\r\nYou can place `guard` in the middle of the chain, all `Errors` before if will be handled by it, and the value it produced, will be passed to the rest of the chain.\r\n\r\nSo, what if the use didn't supply a `guard`? Well, since use have to supply a callback to the `_go`, they can check if the callback they supplied received an `Error` or not like this:\r\n\r\n```js\r\napiReturnAction('...')._go(function(data){\r\n    if (data instanceof Error){\r\n        //handle error here\r\n        ...\r\n    } else {\r\n        // process data here\r\n        ...\r\n    }\r\n});\r\n\r\n```\r\nYeah, it does work, but we don't want force our user to write like above, and we should throw `Error` in case user didn't `guard` them:\r\n\r\n```js\r\nAction.prototype.go = function(cb) {\r\n    return this.action(function(data) {\r\n        if (data instanceof Error) {\r\n            throw data;\r\n        } else if (cb != null) {\r\n            return cb(data);\r\n        }\r\n    });\r\n};\r\n\r\n```\r\nNow if user don't guard `Error`s, we will yell at them when `Error` occurs!\r\n```\r\nnew Action(function(cb){\r\n    readFile('fileA', function(err, data){\r\n        if (err){\r\n            // suppose we got an Error here\r\n            cb(err);\r\n        }else{\r\n\r\n            cb(data);\r\n        }\r\n    });\r\n})\r\n.go() // The Error will be throw!\r\n\r\n```\r\n\r\nFinally, to ease error management, and to attack the [v8 optimization problems](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#2-unsupported-syntax). We recommand use `Action.safe`:\r\n\r\n```js\r\n// this small function minimize v8 try-catch overhead, and make attaching custom Error easy\r\nAction.safe = function(err, fn) {\r\n    return function(data) {\r\n        try {\r\n            return fn(data);\r\n        } catch (_error) {\r\n            return _error;\r\n        }\r\n    };\r\n};\r\n```\r\nAnd use `safe` wrap your `someProcessMayWentWrong`:\r\n```\r\nvar safe = Action.safe;\r\nnew Action(function(cb){\r\n    readFile('fileA', function(err, data){\r\n        if (err){\r\n            // see how to pass an Error to downstream, not reject, not throw, just return\r\n            cb(err);\r\n        }else{\r\n            cb(data);\r\n        }\r\n    });\r\n})\r\n.next(\r\n    safe(new Error(\"PROCESS_ERROR_XXX: process xxx failed when xxx\"), someProcessMayWentWrong)\r\n)\r\n.next(...)\r\n.next(...)\r\n.guard(function(e){\r\n    if (e.message.indexOf('ENOENT') === 0){\r\n        ...\r\n    }\r\n    if (e.message.indexOf('PROCESS_ERROR_XXX') === 0 ){\r\n        ...\r\n    }\r\n})\r\n.go()\r\n\r\n```\r\n\r\nThat's all core functions of `Action` is going to give you.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}